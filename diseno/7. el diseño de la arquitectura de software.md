
# 1. El entendimiento del problema 

Entender el problema que se quiere resolver es fundamental en el diseño de software. Este paso inicial permite identificar las necesidades reales y las restricciones del proyecto, lo que facilita la creación de soluciones efectivas y eficientes. Un análisis meticuloso del problema ayuda a evitar soluciones superficiales que pueden conducir a problemas futuros.

Un ejemplo notable es el desarrollo de **Slack**. Los fundadores identificaron que la comunicación en equipo era ineficiente y fragmentada. En lugar de simplemente automatizar procesos existentes, diseñaron una plataforma que integraba múltiples herramientas de comunicación en un solo lugar, mejorando significativamente la colaboración y productividad.

Diseñar una solución de software no es simplemente automatizar un proceso existente. La automatización puede mejorar la eficiencia, pero no necesariamente resuelve el problema subyacente. Es crucial identificar la raíz del problema y abordarla directamente.

Un caso común es la implementación de sistemas de gestión de tareas que simplemente digitalizan procesos manuales sin mejorar la experiencia del usuario. Esto puede resultar en sistemas que son igualmente ineficientes y frustrantes de usar.

**Airbnb** es un ejemplo de cómo una solución de software puede innovar al abordar la raíz del problema. En lugar de simplemente automatizar el proceso de reserva de alojamiento, Airbnb creó una plataforma que conecta a anfitriones y huéspedes de manera directa, transformando la industria de la hospitalidad.

## Técnicas Existentes para Entender el Problema

1. **Análisis de Requisitos:**
   - **Técnica:** Entrevistas, encuestas, y talleres con stakeholders para recopilar requisitos.
   - En el desarrollo de **Spotify**, se realizaron extensas entrevistas con usuarios para entender sus necesidades y preferencias musicales, lo que permitió diseñar una experiencia de usuario altamente personalizada.

2. **Modelado de Procesos:**
   - **Técnica:** Diagramas de flujo y modelos de procesos para visualizar y analizar el flujo de trabajo actual.
   - **Toyota** utilizó el modelado de procesos para identificar cuellos de botella en su cadena de suministro, lo que llevó a la implementación de un sistema de gestión de inventario más eficiente.

3. **Prototipado:**
   - **Técnica:** Creación de prototipos para validar ideas y obtener feedback temprano.
   - **Dropbox** utilizó un video prototipo para validar su concepto antes de desarrollar el producto completo, lo que les permitió ajustar su enfoque basado en el feedback de los usuarios.

Un pecado en el que ha incurrido por muchos años la industria de software, es la de evitar cuantificar los beneficios de una implementación de software, dichos beneficios deben ser medibles, variables como tiempo, dinero, ventas, errores, etc, debe existir una forma de medir el impacto de una solución de software. 

# 2. Identificación de elementos y sus relaciones

Ejercicios como **design thinking**, **prototipado de ideas**, **testing con usuarios finales** y **mind maps** son esenciales para identificar todos los componentes involucrados en una solución de software. El **design thinking** es una metodología centrada en el usuario que fomenta la empatía y la comprensión profunda del problema. A través de sus fases, se pueden identificar no solo las necesidades de los usuarios, sino también los roles y responsabilidades de los empleados, los stakeholders clave y los sistemas existentes que interactúan con la solución propuesta. Por ejemplo, en la fase de empatizar, se pueden realizar entrevistas y observaciones para entender cómo los empleados interactúan con los sistemas actuales y qué desafíos enfrentan.

El **prototipado de ideas** permite materializar conceptos de manera rápida y económica, facilitando la visualización de cómo la solución interactuará con los sistemas y ecosistemas de software existentes. Al crear prototipos, se pueden identificar posibles problemas de integración y compatibilidad con los sistemas actuales, así como las necesidades de cumplimiento y los términos y condiciones que deben ser considerados. Además, el prototipado ayuda a involucrar a los stakeholders y key players desde el principio, obteniendo su feedback y ajustando la solución según sus necesidades y expectativas.

El **testing con usuarios finales** y el uso de **mind maps** son herramientas poderosas para refinar y validar la solución. El testing con usuarios finales proporciona retroalimentación directa sobre la usabilidad y efectividad de la solución, revelando posibles problemas legales y de cumplimiento que deben ser abordados antes del lanzamiento. Los mind maps, por otro lado, ayudan a visualizar y organizar todos los componentes y relaciones entre ellos, desde los factores organizacionales hasta los legales y constitucionales. Esta visualización facilita la identificación de áreas críticas que requieren atención y asegura que todos los aspectos relevantes sean considerados en el diseño final.

Cuándo utilizo mindmaps?

   1. Relaciones de que está contenido dentro de qué, ejemplo organizaciones, grupos, pasos de procesos, requisitos-correquisitos, causa efecto 
   2. Detectar elementos en común para optimizar flujos
   3. Expresar como considero que funciona algo 
   4. Descomponer el sistema de procesos como por ejempo: registro, validación de registro, el pago de datos, compartir datos, carga de datos, consulta de datos, todos estos procesos son válidos para un mindmap, pero no intentamos hacer un mindmap de todo el sistema porque tiene muchas aristas

Los prototipos pueden ser funcionales o no funcionales, esto va a decidir en que herramienta hacer el prototipo:

   - No funcionales, es decir, que podrían o no ser clickables pero no realizan ninguna función si no que todo es simulado: illustrador, figma, sketch, muchos otros servicios en línea para hacer prototipos. Algunas veces hay herramientas o extensiones para pasar de diseño a código, al menos para tener una plantilla base que ya tenga el diseño aplicado. 
   - Funcional: realizarlo en algún lenguaje o framework que nos permita programar ciertas funciones básicas del prototipo. Puede existir tentación de crear este prototipo en el lenguaje final que se va a realizar el sistema, buscando en algunos casos, de ser posible reutilizar el trabajo y el código hecho en el prototipo.
   - Lo anterior también puede rayar en la metodología de desarrollo de prototipado.  
   - Podemos hacer mezclas rápidas de prototipado funcional y no funcional usando AI generadoras de prototipos de sistemas que algunos casos son semifuncionales. Ejemplo : AI UI Design Generator - Free UI AI Generator By Visily, Lovable, Marblism - AI Employees Who Work for You


Cuando utilizar prototipos?

   1. Cuando existen pantallas o procesos humano computador que son complejos y críticos, requiriendo mucha interacción entre los diseñadores de software y los key players del producto
   2. La forma efectiva de comunicarse con el cliente final o los usuarios es visualmente usando pantallas
Es difícil crear abstracciones de ciertas pantallas por ende el prototipado es una opción


## Influencia de Factores en el Diseño de Software

### Factores Organizacionales y Empleados
Los factores organizacionales y los empleados son cruciales en el diseño de software porque determinan cómo se implementará y utilizará la solución dentro de la empresa. La cultura organizacional, las políticas internas y la estructura jerárquica pueden influir en la adopción y el éxito del software. Por ejemplo, un software diseñado para mejorar la colaboración debe alinearse con la cultura de trabajo en equipo de la organización. Además, los empleados, con sus roles y responsabilidades específicos, deben ser considerados para asegurar que el software sea intuitivo y útil en sus tareas diarias.

### Stakeholders y Key Players
Los stakeholders y key players son esenciales porque proporcionan la visión y los requisitos necesarios para el diseño del software. Estos incluyen desde los directivos que definen los objetivos estratégicos hasta los usuarios finales que interactúan con el software diariamente. Involucrar a estos grupos desde el inicio del proyecto ayuda a asegurar que el software cumpla con las expectativas y necesidades de todos los interesados. Por ejemplo, en el desarrollo de un sistema de gestión de clientes (CRM), es vital obtener feedback de los equipos de ventas, marketing y servicio al cliente para crear una solución que realmente mejore la eficiencia y satisfacción del cliente.

### Sistemas y Ecosistemas de Software Existentes
Los sistemas y ecosistemas de software existentes deben ser considerados para asegurar la compatibilidad e integración con la nueva solución. Ignorar estos aspectos puede resultar en problemas de interoperabilidad y duplicación de esfuerzos. Por ejemplo, si una empresa ya utiliza un sistema ERP (Enterprise Resource Planning), el nuevo software debe integrarse sin problemas con este sistema para evitar interrupciones en los procesos de negocio. Además, es importante considerar las compliances, términos y condiciones, y factores legales y constitucionales para asegurar que el software cumpla con todas las regulaciones aplicables y proteja los datos y derechos de los usuarios.


# 3. Descomposición del sistema
La descomposición del sistema y el diseño con componentes son fundamentales en el diseño de software por varias razones clave:

## Escalabilidad y Mantenibilidad
Descomponer un sistema en componentes más pequeños y manejables permite que cada componente se desarrolle, pruebe y mantenga de manera independiente. Esto facilita la escalabilidad del sistema, ya que se pueden agregar o modificar componentes sin afectar el sistema completo. Por ejemplo, en una arquitectura de microservicios, cada servicio puede ser escalado de manera independiente según la demanda, lo que mejora la eficiencia y la capacidad de respuesta del sistema.

## Reutilización y Eficiencia
El diseño con componentes promueve la reutilización de código, lo que puede acelerar el desarrollo y reducir costos. Los componentes bien diseñados pueden ser reutilizados en diferentes proyectos o partes del mismo proyecto, evitando la duplicación de esfuerzos. Un ejemplo clásico es el uso de bibliotecas y frameworks en el desarrollo de software, donde componentes predefinidos y probados se integran para construir nuevas aplicaciones de manera más rápida y confiable.

## Claridad y Gestión de Complejidad
Dividir un sistema complejo en componentes más pequeños ayuda a gestionar la complejidad del proyecto. Cada componente tiene una responsabilidad claramente definida y se comunica con otros componentes a través de interfaces bien establecidas. Esto no solo facilita la comprensión del sistema, sino que también mejora la colaboración entre equipos de desarrollo, ya que cada equipo puede enfocarse en componentes específicos sin necesidad de entender todo el sistema en detalle.

## Pasos y Técnicas para la Descomposición del Sistema

### 1. Identificación del Sistema y sus Límites
El primer paso en la descomposición del sistema es identificar claramente el sistema en cuestión y definir sus límites. Esto implica entender el alcance del sistema, sus objetivos y las restricciones que lo afectan. Técnicas como el **análisis de requisitos** y la **definición del alcance** son esenciales en esta etapa. Por ejemplo, en el desarrollo de un sistema de gestión de inventarios, es crucial definir qué procesos de inventario se incluirán y cuáles no.

### 2. Descomposición Jerárquica
Una vez definidos los límites del sistema, se procede a descomponerlo en componentes más pequeños y manejables. La **estructura de desglose del trabajo (EDT)**, también conocida como **Work Breakdown Structure (WBS)**, es una técnica comúnmente utilizada para este propósito. La EDT organiza visualmente los entregables del proyecto en diferentes niveles jerárquicos, facilitando la identificación de tareas y sub-tareas. Por ejemplo, en un proyecto de desarrollo de software, la EDT puede dividirse en módulos, submódulos y funciones específicas.

### 3. Refinamiento Paso a Paso
El refinamiento paso a paso, o **stepwise refinement**, es una técnica que implica descomponer cada componente en subcomponentes hasta que cada parte sea lo suficientemente simple para ser manejada de manera independiente. Esta técnica es especialmente útil en el diseño de sistemas complejos, ya que permite abordar problemas grandes dividiéndolos en problemas más pequeños y manejables. Por ejemplo, en el diseño de un sistema de comercio electrónico, el refinamiento paso a paso puede descomponer el sistema en componentes como gestión de usuarios, procesamiento de pagos y gestión de inventarios.

### 4. Modelado y Diagramas
El uso de **diagramas de flujo de datos (DFD)** y **diagramas de entidad-relación (ERD)** ayuda a visualizar cómo los datos fluyen a través del sistema y cómo se relacionan las diferentes entidades⁴. Estos diagramas proporcionan una representación gráfica del sistema, facilitando la identificación de interacciones y dependencias entre componentes. Por ejemplo, un DFD puede mostrar cómo los datos de los pedidos de clientes se procesan a través de diferentes módulos del sistema de gestión de pedidos.

### 5. Validación y Verificación
Finalmente, es crucial validar y verificar la descomposición del sistema para asegurar que todos los componentes y sus interacciones se han identificado correctamente. Técnicas como las **revisiones de diseño** y las **pruebas de integración** son esenciales en esta etapa. Estas técnicas ayudan a identificar posibles problemas y asegurar que el sistema descompuesto funcionará como un todo cohesivo. Por ejemplo, en un proyecto de desarrollo de software, las pruebas de integración aseguran que los diferentes módulos del software funcionen correctamente cuando se combinan.

**Ley de Conway**:
Formulada por Melvin Conway en 1967, dice básicamente:

*"Cualquier organización que diseñe un sistema terminará produciendo un diseño cuya estructura es una copia de la estructura de comunicación de esa organización."*

En otras palabras, la arquitectura de un sistema refleja cómo las personas dentro de la organización se comunican y colaboran.


### Ejemplo 1: Organización **tight** (muy centralizada y jerárquica)

**Contexto organizacional**:

* Equipos muy jerárquicos, comunicación centralizada a través de gerentes.
* Cada equipo se enfoca en un componente del sistema, pero todo pasa por el mismo canal de aprobación.

**Resultado en arquitectura**:

* El sistema termina con una arquitectura **monolítica**, porque los equipos no se comunican libremente entre sí.
* Todos los cambios deben pasar por un punto central, lo que lleva a dependencias fuertes y acoplamiento.

* Una empresa bancaria grande donde cada módulo de la aplicación (cuentas, pagos, préstamos) depende de un comité central para integrar cambios. Esto genera un **sistema monolítico** donde los módulos están altamente interdependientes.

### Ejemplo 2: Organización **desacoplada** (autónoma y modular)

**Contexto organizacional**:

* Equipos pequeños, autónomos y especializados.
* Cada equipo tiene control sobre un servicio específico y comunica cambios mediante interfaces bien definidas.

**Resultado en arquitectura**:

* El sistema termina con una arquitectura **modular o de microservicios**, porque los equipos pueden desarrollar de forma independiente sin bloquear a los demás.
* La comunicación se reduce a API o eventos, reflejando la estructura de la organización.

* Una empresa de e-commerce donde un equipo gestiona inventario, otro pedidos, otro pagos. Cada equipo expone APIs, permitiendo que cada servicio evolucione de manera independiente. Esto genera una arquitectura **desacoplada y flexible**, ideal para escalar.


En resumen: la **estructura organizacional condiciona la arquitectura**. Si la organización es rígida y centralizada, el sistema tiende a ser monolítico. Si la organización es autónoma y modular, el sistema refleja esa independencia en microservicios o componentes desacoplados.

# 4. Diseño con componentes

## Paso a Paso para el Diseño por Componentes de una Solución de Software

### 1. Definición de Requisitos 

Comienza por entender y documentar los requisitos funcionales y no funcionales del sistema. Esto incluye identificar las necesidades del usuario, las restricciones del sistema y los objetivos del proyecto.

**Técnicas y Herramientas:**
- **Entrevistas y Encuestas:** Recopila información de los stakeholders y usuarios finales.
- **Documentación de Requisitos:** Utiliza herramientas como **Jira** o **Confluence** para documentar y gestionar los requisitos.

### 2. Análisis del Sistema

Descompone el sistema en sus componentes básicos y analiza cómo interactúan entre sí. Los diagramas de flujo de datos y de entidad-relación ayudan a visualizar las interacciones y dependencias entre los diferentes componentes del sistema.

**Técnicas y Herramientas:**
- **Diagramas de Flujo de Datos (DFD):** Herramientas como **Lucidchart** o **Microsoft Visio**, o diagramas de bloques en general 
- **Diagramas de Entidad-Relación (ERD):** Utiliza **MySQL Workbench** o **Draw.io**.

### 3. Diseño de la Arquitectura

Define la arquitectura del sistema, especificando los componentes principales y sus interacciones. Selecciona los patrones de diseño adecuados para asegurar que el sistema sea escalable, mantenible y eficiente.

**Técnicas y Herramientas:**
- **Patrones de Diseño:** Aplica patrones como MVC (Model-View-Controller) o Microservicios.
- **Herramientas de Modelado:** **Enterprise Architect** o **Archimate** o diagramas de bloques
- patrones arquitectónicos: https://learn.microsoft.com/en-us/azure/architecture/patterns/


### 4. Prototipado

Crea prototipos de los componentes clave para validar su funcionalidad y obtener feedback temprano. El prototipado rápido permite iterar sobre el diseño antes de la implementación completa.

**Técnicas y Herramientas:**
- **Prototipado Rápido:** Herramientas como **Figma**, **Sketch** o **Adobe XD**.
- **Pruebas de Usabilidad:** Realiza pruebas con usuarios finales para validar el prototipo.

### 5. Implementación de Componentes

Desarrolla cada componente de manera independiente, asegurando que cada uno cumpla con su contrato definido y pueda ser integrado con otros componentes. Utiliza control de versiones e integración continua para gestionar el código y las versiones del software.

**Técnicas y Herramientas:**
- **Control de Versiones:** Utiliza **Git** y plataformas como **GitHub** o **GitLab**.
- **Integración Continua:** Herramientas como **Jenkins** o **CircleCI**.

### 6. Pruebas e Integración

Realiza pruebas unitarias para cada componente y pruebas de integración para asegurar que los componentes funcionen correctamente cuando se combinan. Esto ayuda a identificar y resolver problemas antes del despliegue.

**Técnicas y Herramientas:**
- **Pruebas Unitarias:** Frameworks como **JUnit** para Java o **pytest** para Python.
- **Pruebas de Integración:** Herramientas como **Selenium** o **PlayWright**.

### 7. Despliegue y Mantenimiento

Despliega la solución en el entorno de producción y establece un plan de mantenimiento para asegurar su funcionamiento continuo. Monitorea el sistema para detectar y resolver problemas de manera proactiva.

**Técnicas y Herramientas:**
- **Despliegue Automatizado:** Herramientas como **Docker** y **Kubernetes**.
- **Monitoreo y Mantenimiento:** Utiliza **Prometheus** y **Grafana** para monitorear el rendimiento del sistema.


# 5. Domain driven design

https://medium.com/inato/an-introduction-to-domain-driven-design-386754392465

https://domain-driven-software.com/an-introduction-to-domain-driven-design-ddd-1025bce518c2

https://mahmudul.dev/posts/domain-driven-design-nextjs/

# Tecnologías, arquitecturas y tendencias del backend

## arquitecturas de alto nivel para la implementación de backends

### REST (Representational State Transfer)

REST is an architectural style for designing networked applications. It relies on stateless, client-server communication, usually over HTTP/HTTPS, and uses standard HTTP methods (GET, POST, PUT, DELETE, UPDATE) to operate on resources. Resources are identified by URLs, and the server provides responses in a variety of formats, such as JSON or XML.

REST requiere de un servidor que opera similar a un webserver, recibe un request de un resource y una operación, el servidor posee algún tipo de router que basado en ese request determina la función de alguna clase que deberá ser llamado, recibiendo por parámetro el request enviado y también habilitando un objeto response para enviar la respuesta en el formato configurado para cumplir con el protocolo stateless de http. 

- simple
- universal, allowing diversity of clients
- based on web technology
- decouple client and server layers
- usual for api development
- se puede implementar en prácticamente cualquier lenguaje sin embargo existen multiples frameworks para facilitar su implementación y para proveer facilitadores que se encarguen de manejar detalles de arquitecturas como timeouts, cantidad de conexiones, escalabilidad, threads, caches, sesiones y más
- le corresponde al arquitecto, equipo de ingenieros o la persona responsable de su implementación, de crear un diseño que obedezca a la estructura, organización y escalabilidad que la organización requiera
- on premise, cloud or on premise serverless/or cloud

### GraphQL
GraphQL is a query language and runtime for APIs that allows clients to request only the data they need. Unlike REST, which exposes fixed endpoints that return predefined data structures, GraphQL lets clients define the shape and size of the data in a single request. It also allows multiple resources to be fetched in a single query, reducing the number of network requests.

- efficient data retrieval, reducing over-fetching and under-fetching.
- strongly typed schema, providing clear API contracts.
- flexibility in evolving APIs without breaking clients.
- ofrece diferentes tipos de operaciones llamadas queries, mutations and subscriptions para crear toda la arquitectura de request response de graphql
- aún con esas ventajas, graphql requiere que se implementen resolvers para cada dataset que se quiera procesar, haciendo que los backends duren más tiempo en desarrollarse y que requieren un mantenimiento mayor para mantener esos resolvers actualizados con la capa de datos y en muchas cosas con los ORMs
- on premise, cloud or on premise serverless/or cloud

### Serverless Architecture
Serverless architecture allows developers to build and deploy applications without managing the underlying server infrastructure. In this model, cloud providers automatically manage the server resources, scaling them based on demand. Functions-as-a-Service (FaaS), like AWS Lambda or Azure Functions, are a common implementation of serverless architecture. Existen varios frameworks para la implementación de serverless, como por ejemplo https://www.serverless.com/, capaz de hacer deployment en la mayoría de los cloud services comerciales.

Las arquitecturas serverless van en extremo asociadas o de la mano con los cloud providers o con tecnologías contenerizadas o virtuales que permitan el alojamiento de recursos computacionales (CPU, Memory, Bus, Cache, Storage) en formá dinámica y elástica. Eso lleva consigo un problema de warnup que en algunos lenguajes suelen pagar un penalty muy alto en tiempo de respuesta. 

- Reduced operational complexity, as developers don't manage servers.
- Cost-efficiency, as billing is based on actual usage.
- Automatic scaling and high availability.
- on premise or cloud

### gRPC (gRPC Remote Procedure Calls)
A modern, high-performance, open-source framework for remote procedure calls (RPC) developed by Google. It uses Protocol Buffers (protobuf) for serialization and supports multiple languages.
Use Cases: Microservices communication, real-time services, and high-performance applications.

principalmente supported by Go, Java, C++, python, C#, nodejs and available in azure, aws, digital ocean, gcp

```
message User {
    int32 id = 1;
    string name = 2;
    string email = 3;
}

service UserService {
    rpc GetUserById(UserIdRequest) returns (UserResponse);
}

message UserIdRequest {
    int32 id = 1;
}

message UserResponse {
    User user = 1;
}
```

### Event-Driven Architecture (EDA)
A design architectural pattern in which decoupled components (producers and consumers) communicate asynchronously via events. This architecture is often implemented using message brokers like Kafka or RabbitMQ, there's a bunch of messaging systems, cloud services usually offers a native platform for this. It also requires an event listener in the client side. 

This architecture is very practical for Real-time applications, distributed systems, and microservices.

https://activitypub.rocks/


### Microservices Architecture
An architectural style that structures an application as a collection of loosely coupled services. Each service is independently deployable and communicates over a network. In many cases microservices are design using isolated services and databases, but such design can be adapt depending of the business case. 

Microservices is normally associate to too complex to manage, code and maintain because its purpose of loosely coupled services, but this can be easily interpreted under the eye of the conceptual design of the services and the intention of the microservices. Is deserible as a good pratice the main reason why the architect is looking for such kind of separation. 

Microservices frameworks are important to easy the implementation and maintenance of the services code. Spring Boot, Micronaut, NestJS, DJango + REST. 


This is ideas for large, complex applications that need to scale development and deployment independently.

### Monolithic Architecture
A traditional approach where the entire application is a single, unified unit. All components are tightly integrated and run as a single service. Ideal for small to medium-sized applications with simple requirements.

Ruby on Rails (RoR) se considera una arquitectura monolítica por defecto. En una arquitectura monolítica, todos los componentes de la aplicación, como la lógica de negocio, la capa de datos y la interfaz de usuario, están integrados en un único proyecto o aplicación que se ejecuta como una sola unidad.

*Características de Ruby on Rails en Arquitectura Monolítica:*

*_Convención sobre Configuración_*: Rails sigue el principio de "Convención sobre Configuración", lo que significa que toma muchas decisiones por defecto, permitiendo a los desarrolladores enfocarse más en la lógica de negocio que en la configuración.

*_MVC (Model-View-Controller)_*: Rails sigue el patrón de diseño MVC, donde:

- Model: Representa la lógica y estructura de la base de datos.
- View: Maneja la presentación de datos al usuario.
- Controller: Gestiona la interacción del usuario, invoca al modelo y selecciona la vista que se debe renderizar.

*_Integración Completa_*: Rails ofrece una solución integral que incluye el manejo de bases de datos, enrutamiento, controladores, vistas y la lógica de negocio en un solo marco, facilitando el desarrollo rápido y estructurado.


### API Gateway Architecture
API gateway sits between clients and backend services. It handles request routing, composition, protocol translation, and other cross-cutting concerns like authentication and rate limiting. Ideal for Microservices-based applications, where an API gateway can manage service interactions. Something important in api gateway architecture es la capacidad de ofrecer un único punto de entrada para multiples servicios implementados en múltiples tecnologías y protocolos de comunicación, seguridad, transporte y red. 


Luego de que se decide la topología arquitectónica de un backend, sigue la decisión de los componentes arquitectónicos que se le van a agregar a dicha topología y el stack de tecnologías.

## Componentes arquitectónicos y stack de tecnologías 

esta no es una decisión fácil, pues se debe diseñar a partir de la combinación de los requerimientos de negocio versus todos los componentes arquitectónicos versus el panteon de tecnologías existentes cuyas posiblidades, capacidades y limitaciones son amplias y cada una puede responder de mejor manera según el escenario donde se implemente. 

quien diseñe la arquitectura de software (el arquitecto talvez...) tiene la gran responsabilidad de juntar todos esos superpoderes para crear un diseño arquitectónico del backend que:
1. responde a los requerimientos del negocio
2. es capaz de solventar los requerimientos no funcionales: seguridad, recursos, escalabilidad, tolerancia a fallas, disponibilidad 
3. es costo efectiva
4. el impacto que va a tener en el equipo de desarrollo en general: software, diseño de software, devops, qa. el impacto puede ser en recurso humano, curva de aprendizaje, tiempo de desarrollo, tamaño del equipo, herramientas de qa y devops; tiene mucha incidencia incluso en la motivación del equipo de trabajo


## resumen de arquitecturas a alto nivel

![Image](./images/patronesdisenoarqui.gif)
