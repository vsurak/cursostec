## Qu√© es el dise√±o de software ##

### 1. Introducci√≥n al dise√±o de software

El profesor realizar√° una explicaci√≥n magistral con dicha introducci√≥n, dejando claro con costos de dinero en d√≥lares $ y tiempo, sobre el efecto que tienen las decisiones del dise√±o en las etapas tempranas y avanzadas de los proyectos de software. Se hace hincapi√© de la influencia del dise√±o cuando se negocian proyectos de software. 

El dise√±o de software es un proceso que se da una vez que se sabe "el qu√©", es decir, cuando se conoce lo que se quiere hacer, ya sea de un sistema, servicio, agente, proceso, integraci√≥n, aplicaci√≥n, soluci√≥n de infraestructura, dispositivo o cualquier otro saber donde se requiera construir un algo, este puede ser digital, f√≠sico o ambos. 

Por eso siempre nuestra primer misi√≥n debe ser clarificar el qu√©. Proceda a realizar preguntas que le permita clarificar lo que se quiere hacer en los siguientes use cases:

tips:
- c√≥mo va a funcionar el sistema
- que se desea del sistema finalmente
- cu√°l es la ganancia de la empresa con el sistema
- c√≥mo se ver√≠a el sistema visualmente, UI - ideas
- equipo o la forma en que se podr√≠a poner a funcionar
- c√≥mo lo acceden
- sistemas operativos, lenguajes de programaci√≥n, bases de datos
- estretegias que se deben seguir para resolver el problema


a) En la fila: BigMoney es una empresa financiera que quiere tener en todas sus sucursales un sistema para quitar las filas de atenci√≥n, en su lugar, las personas al llegar a una sucursal o bien desde sus tel√©fonos previamente, pueden tomar una ficha seg√∫n el tipo de tr√°mite que deseen hacer, de esa forma puedan ser llamadas en orden sin estar haciendo filas.


b) Venta de sandwiches: Prensaditos es una tienda de sandwiches que siempre ha vendido sus sandwiches por medio de una caja registradora en la ventanita f√≠sica, atentiendo pedidos de express por tel√©fono, whatsapp y uber eats  recientemente. En palabras de uno de los due√±os "nuestros sandwiches se han vuelto tan famosos en toda la zona, que es el momento de crecer para hacer llegar nuestros sandwiches a m√°s lugares y para ello, no podemos seguir sin un sistema que nos agilice las √≥rdenes por medio de todos nuestros canales de venta"


Existen macro componentes que pueden dise√±arse en una soluci√≥n de software, como por ejemplo:
- Frontend
- Backend
- Estrategias de seguridad
- Bases de datos
- Recursos on premises
- Recursos cloud
- Recuperaci√≥n ante fallas
- Servicios 
- Procesos en background
- Integraciones a terceros
- CI/CD
- Proceso de desarollo y delivery
- An√°lisis de riesgos
- Documentaci√≥n
- Comunicaci√≥n 


Para dise√±ar soluciones de software los ingenieros nos valemos de modelos, es decir, representaciones o abstraciones que nos sirvan de mapa o gu√≠a del c√≥mo es que se quiere lograr fabricar una soluci√≥n. Para lograr hacer esos modelos es necesario que desarrollemos destrezas y conocimiento en varias t√©cnicas de dise√±o que aplican a la construcci√≥n de pr√°cticamente cualquier sistema de software, las cuales vamos a abordar a continuaci√≥n. 

---

### 2. Dise√±o de classes y patrones de dise√±o

El dise√±o de clases es uno de los procesos m√°s fundamentales en el desarrollo de software, 

El tema de patrones de dise√±o para programas orientados a objetos se abordan desde el curso de programaci√≥n orientada a objetos, estructuras de datos, an√°lisis de algoritmos y otros. Se recomienda repasar dichos dise√±os que son fundamentales para la implementaci√≥n de frontend y backends. 

[Patrones de Dise√±o](https://refactoring.guru/design-patterns)


**Patrones Creacionales:**
- Singleton
- Abstract Factory
- Builder

**Patrones estructurales**
- Adapter
- Facade
- Bridge
- Decorator
- Proxy

**Patrones de Behavior**
- Observer
- Visitor
- Strategy
- Chain of responsability
- Mediator
- Dependency injection: 
 
[Understanding Dependency Injection](https://medium.com/@sardar.khan299/understanding-dependency-injection-a-powerful-design-pattern-for-flexible-and-testable-code-5e1161dd37dd) 


[Dependency Injection Example](src/dependencyinjection)

---
### 3. Dise√±o de la seguridad de un software

#### Authentication 

Cuando hablamos de autenticaci√≥n, estamos hablando del procedimiento que se sigue para identificar qui√©n es la persona o el sistema que est√° interactuando con otro sistema. C√≥mo me garantizo que es qui√©n dice ser.

Este dise√±o se sugiere que debe tener al menos 2 cosas del tri√°ngulo de la seguridad: 

a) algo que se sabe : una clave, un pin, password.

b) algo que se posee : un token, una llave, una tarjeta, un chip

c) algo que se es : huellas dactilares, reconocimiento facial, iris del ojo, adn

La autenticaci√≥n b√°sica es basada en usuario y password, sin embargo, este esquema ha sufrido muchos ataques lo cual ha llevado a la industria a crear mecanismos que refueren el proceso de autenticaci√≥n.

*Token-Based Authentication* 

Token-based authentication is a popular approach for securing applications and APIs. It involves issuing a token to a client (such as a user or an application) upon successful validation of credentials. The client then includes this token in subsequent requests to access protected resources.

![Image](./images/tokenauth.jpg)

User Authentication: 

- The user logs in using their credentials (e.g., username and password).
- The server validates the credentials and generates a token.
- This token represents the user‚Äôs identity and permissions.

Token Issuance: 

- The server issues a token (usually a JSON Web Token or JWT) to the client.
- The token contains claims (information) about the user, such as their user ID, roles, and expiration time.
- The token is digitally signed to ensure its integrity.

Token Storage: 

- The client (e.g., a web browser or mobile app) stores the token securely (e.g., in local storage or a cookie).

Subsequent Requests: 

- When the client makes requests to protected resources (e.g., APIs or routes), it includes the token in the request headers (usually as an ‚ÄúAuthorization‚Äù header).
- The server verifies the token‚Äôs signature and decodes its claims.
- If the token is valid and not expired, the server grants access to the requested resource. 

*Multi factor or Two factor authentication*

Something You Know: This is typically a password or a response to a security question.
Something You Own: It could be a smartphone app (like Microsoft Authenticator) that generates verification codes or a physical token-generating device.
Something You Are: Usually a biometric trait like a fingerprint or face scan.

![Image](./images/2fa-diagram.png)

*OAuth 2.0*  

is an essential protocol for securing applications and APIs. I‚Äôll break it down in a similar manner:

![Image](./images/oauthdiagram.png)

_Roles:_

- Resource Owner: The end-user who can grant access to protected resources.
- Resource Server: Hosts the protected resources (usually an API).
- Client: Represents the application requesting access on behalf of the Resource Owner.
- Authorization Server: Authenticates the Resource Owner and issues access tokens.

_Grant Types (Flows):_

- Authorization Code Flow: Used by web apps (executing on a server) and mobile apps (with Proof Key for Code Exchange, PKCE).
- Implicit Flow with Form Post: For JavaScript-centric apps (Single-Page Applications) executing in the user‚Äôs browser.
- Resource Owner Password Flow: Trusted apps (not recommended for public clients).
- Client Credentials Flow: For machine-to-machine communication.

_Endpoints:_
- /authorize: Initiates the authorization process.
- /oauth/token: Exchanges authorization code or credentials for an access token. 


Resumen:

![Image](./images/authentication%20design.gif)


#### Authorization

La autorizaci√≥n tiene que ver con determinar si la tarea o acci√≥n que quiere hacer el usuario o sistema identificado, tiene permitido o no realizar, y como otorgar el m√≠nimo de privilegios posible a dicho usuario o sistema para que est√© limitado a solo lo necesario para realizar una tarea. 

*Role-Based Access Control (RBAC)* 

RBAC authorizes and restricts system access based on user roles within an organization.

- Role Assignment: Users are assigned specific roles (e.g., admin, manager, employee). 

- Role Authorization: Active roles must be authorized. 

- Permission Authorization: Users can only exercise permissions authorized for their active role. 

- Benefits: Efficient, scalable, and minimizes unauthorized access. 


*Access Control Lists (ACL):* 

ACL specifies permissions for individual users or groups on specific resources.

- Each resource has an associated list of users/groups and their allowed actions.
- Fine-grained control over access (read, write, execute).
- Benefits: Granular control but can become complex to manage.

*Policy-Based Access Control (PBAC):* 

PBAC determines access dynamically based on rules and policies. 

- Policies define conditions for access (e.g., time of day, location, user attributes).
- Access decisions made at runtime based on policy evaluation.
- Benefits: Flexible, adaptable, and context-aware.




#### Exception Handling
El manejo de excepciones es una parte cr√≠tica del desarrollo de software robusto. Un mal manejo puede causar ca√≠das, fugas de informaci√≥n sensible o una experiencia de usuario deficiente. Este documento resume buenas pr√°cticas para:

* Manejar errores sin comprometer la estabilidad del sistema.
* Ocultar mensajes de error al usuario final.
* Loguear adecuadamente los errores para seguimiento.
* Asegurar que el sistema contin√∫e ejecut√°ndose incluso tras errores.

**Buenas pr√°cticas generales** 

1. **Nunca mostrar errores t√©cnicos al usuario final**: Siempre retorna un mensaje gen√©rico como *"Ocurri√≥ un error, por favor intente m√°s tarde."*
2. **Usar bloques `try-catch` selectivos**: No envolver todo el c√≥digo en `try-catch`. Solo donde hay riesgo real de error.
3. **Loguear siempre los errores internos**: Usa un sistema de logs como `winston` (Node), `logback` (Java) o `logging` (Python).
4. **Clasifica los errores**: Divide entre errores esperados (ej: usuario no autenticado) y errores inesperados (ej: null pointer, fallos de red).
5. **Evita silenciosamente ignorar excepciones**: Siempre registra o maneja adecuadamente.
6. **Centraliza el manejo de errores si es posible**: Especialmente en frameworks modernos que soportan middleware o interceptores.


**Angular - interceptor para ocultar errores y loguear**

```typescript
import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { ErrorService } from './error.service'; // Tu servicio de logs

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  constructor(private errorService: ErrorService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        this.errorService.log(error); // Guarda el log internamente o env√≠alo a backend
        alert('Algo sali√≥ mal. Intenta de nuevo.'); // Mensaje gen√©rico
        return throwError(() => error); // Mantener trazabilidad para debugging
      })
    );
  }
}
```


**Manejo global de excepciones -- Java (Spring Boot) - microservicio resiliente**

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception ex) {
        LoggerFactory.getLogger(getClass()).error("Error inesperado", ex);
        return new ResponseEntity<>("Error interno, intente m√°s tarde.", HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<String> handleBadRequest(BadRequestException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }
}
```

**Servicio con try-catch para resiliencia**

```java
@Service
public class UserService {

    public Optional<User> findByIdSafe(Long id) {
        try {
            return Optional.of(userRepository.findById(id).orElseThrow());
        } catch (NoSuchElementException e) {
            LoggerFactory.getLogger(getClass()).warn("Usuario no encontrado: " + id);
            return Optional.empty(); // Devuelve estado controlado
        } catch (Exception ex) {
            LoggerFactory.getLogger(getClass()).error("Error al buscar usuario", ex);
            return Optional.empty();
        }
    }
}
```

**Python Backend (Flask) - Error handler global**

```python
from flask import Flask, jsonify
import logging

app = Flask(__name__)
logging.basicConfig(level=logging.ERROR)

@app.errorhandler(Exception)
def handle_exception(e):
    app.logger.error("Unhandled exception: %s", str(e))
    return jsonify(error="Error interno del servidor"), 500
```

**Funci√≥n segura con manejo de errores**

```python
def get_user_by_id(user_id):
    try:
        user = db.find_user(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        return user
    except ValueError as ve:
        logging.warning(f"Advertencia: {ve}")
        return None
    except Exception as ex:
        logging.error(f"Error cr√≠tico: {ex}")
        return None
```


**Estrategias comunes** 


| Estrategia              | Descripci√≥n                                                                  |
| ----------------------- | ---------------------------------------------------------------------------- |
| **Try/Catch local**     | Controla el fallo espec√≠fico sin afectar toda la app.                        |
| **Valores por defecto** | Devuelve resultados v√°lidos a√∫n ante fallo (ej: listas vac√≠as).              |
| **Colas de errores**    | En sistemas distribuidos, env√≠a a Dead Letter Queue.                         |
| **Circuit Breakers**    | En microservicios, para detener temporalmente llamadas a servicios fallando. |
| **Retry Policies**      | Reintentar ciertas operaciones (ej: redes) bajo reglas.                      |
| **Fallbacks**           | Alternativa funcional si algo falla.                                         |
| **Logs estructurados**  | Para poder analizar y tomar decisiones automatizadas.                        |


#### Monitor, Audit, Logs

El monitoreo y logging son fundamentales para mantener un software **estable, auditable, mantenible y confiable**. Permiten:

* Detectar **fallas en tiempo real**.
* Auditar operaciones de usuarios y cambios cr√≠ticos.
* Diagnosticar errores complejos o intermitentes.
* Medir uso, rendimiento y comportamientos del sistema.
* Anticipar problemas antes de que impacten al usuario.


**¬øC√≥mo se usan los logs?** 

| Objetivo                | Ejemplo                                                          |
| ----------------------- | ---------------------------------------------------------------- |
| **Auditor√≠a**           | Registro de accesos, operaciones financieras, cambios en cuentas |
| **Errores**             | Excepciones, fallos de integraci√≥n, timeouts                     |
| **M√©tricas**            | Tiempo de respuesta, n√∫mero de solicitudes, carga por endpoint   |
| **Alertas autom√°ticas** | Notificaciones en caso de errores 500, picos de uso, etc.        |
| **Cumplimiento legal**  | Retenci√≥n de registros por normativas (ej. GDPR, HIPAA)          |



**Buenas pr√°cticas de logging**

1. **Loguear en m√∫ltiples niveles**: info, debug, warn, error, fatal.
2. **Estructurar los logs** (JSON o campos clave): evita logs planos.
3. **No loguear datos sensibles**: como contrase√±as o tarjetas.
4. **Incluir contexto**: ID de usuario, IP, endpoint, timestamp, etc.
5. **Correlaci√≥n de logs**: usa `requestId` o `traceId` o `referenceid` alg√∫n id que haga relaci√≥n.


**Ejemplo en .NET (C#) usando `Serilog`**

```csharp

using Serilog;

var builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console()
    .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day)
    .Enrich.FromLogContext()
    .Enrich.WithProperty("Application", "MyApp"));

var app = builder.Build();

app.MapGet("/user/{id}", (int id) => {
    Log.Information("Buscando usuario {UserId}", id);
    try {
        if (id == 0) throw new Exception("ID inv√°lido");
        return Results.Ok(new { id });
    } catch (Exception ex) {
        Log.Error(ex, "Error al buscar usuario");
        return Results.Problem("Error interno");
    }
});

app.Run();
```

**Ejemplo en Node.js + TypeScript usando `winston`**

```ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
  ],
});
```

```ts
import express from 'express';
import { logger } from './logger';

const router = express.Router();

router.get('/user/:id', (req, res) => {
  const userId = req.params.id;
  logger.info(`Request for user ${userId}`, { userId });

  try {
    if (userId === '0') throw new Error('Invalid user ID');
    res.json({ userId });
  } catch (err) {
    logger.error('Error fetching user', { error: err.message });
    res.status(500).json({ message: 'Internal error' });
  }
});

export default router;
```


**¬øC√≥mo funciona AWS CloudWatch?** 
Es el sistema de observabilidad de Amazon. Permite:

* Recibir logs de aplicaciones y servicios (EC2, Lambda, ECS, etc).
* Crear **dashboards y m√©tricas personalizadas**.
* Definir **alarmas y alertas** autom√°ticas.
* Integrarse con otras herramientas como SNS, EventBridge y Lambda.

**Componentes clave de CloudWatch:**

| Componente     | Descripci√≥n                                         |
| -------------- | --------------------------------------------------- |
| **Logs**       | Almacena logs de apps y servicios                   |
| **Metrics**    | Datos num√©ricos como uso de CPU, errores, latencia  |
| **Alarms**     | Disparadores ante condiciones (ej: > 5 errores/seg) |
| **Dashboards** | Visualizaci√≥n de m√©tricas y estado                  |
| **Insights**   | Consulta y an√°lisis avanzado de logs                |

Todos los proveedores de cloud services ofrecen algun servicio para logs, se comportan todos muy similar. 

Otros productos especializados en logging y monitoreo :


| Producto         | Funci√≥n destacada                                                                                                                                                              |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Datadog**      | Plataforma todo en uno para m√©tricas, logs, trazas, APM y monitoreo de infraestructura. Permite dashboards en tiempo real y alertas configurables.                             |
| **ELK Stack**    | Conjunto de herramientas (Elasticsearch, Logstash, Kibana) para ingesti√≥n, b√∫squeda y visualizaci√≥n avanzada de logs. Muy usado en arquitecturas on-premise y cloud.           |
| **Grafana Loki** | Sistema de agregaci√≥n de logs altamente escalable e integrado con Grafana. Permite consultas estructuradas tipo PromQL sobre logs.                                             |
| **Sentry**       | Especializado en monitoreo de errores con trazabilidad hasta la l√≠nea de c√≥digo. Muy usado en frontend y backend para detectar fallos espec√≠ficos.                             |
| **New Relic**    | Observabilidad full stack con trazas distribuidas, an√°lisis de rendimiento, errores, logs, y m√©tricas de negocio. F√°cil de integrar con m√∫ltiples lenguajes y servicios cloud. |


### 4. Dise√±o del SDLC (Software Development Life Cycle)

El **SDLC** es un marco metodol√≥gico que define c√≥mo se desarrolla software de manera estructurada, asegurando calidad, mantenimiento y escalabilidad. Abarca **todas las fases**: an√°lisis, dise√±o, desarrollo, pruebas, despliegue y operaci√≥n. Hoy, la integraci√≥n de **herramientas modernas**, **metodolog√≠as √°giles** y **IA de desarrollo** permite acelerar los ciclos y mejorar la colaboraci√≥n.


### 4.1. Documentaci√≥n y elementos clave en el SDLC

En la pr√°ctica, documentar correctamente el SDLC es crucial para **evitar errores, reducir retrabajo y mantener la trazabilidad de decisiones**.

#### a) Requerimientos

* **Funcionales**: qu√© debe hacer el sistema (ej.: ‚Äúlos usuarios pueden enviar y recibir mensajes en tiempo real‚Äù).
* **No funcionales**: rendimiento, escalabilidad, seguridad, disponibilidad (ej.: ‚Äúel sistema debe soportar 10,000 usuarios concurrentes‚Äù).
* **Herramientas**: Notion, Confluence, ClickUp para documentaci√≥n centralizada.

#### b) Dise√±o de arquitectura

* Diagramas de componentes y despliegue: UML, C4 Model, Structurizr, Draw\.io.
* **Arquitectura moderna**: microservicios desacoplados, serverless (AWS Lambda, Supabase Functions), API-first.
* **Supabase**: permite crear bases de datos Postgres con APIs autom√°ticas, autenticaci√≥n y almacenamiento de archivos, acelerando la entrega de backends funcionales sin codificaci√≥n extensa.

#### c) Planificaci√≥n y backlog

* Definir **epics**, historias (stories) y tareas (tasks).
* **Epics**: grandes bloques funcionales que se descomponen en historias m√°s peque√±as. Ej.: ‚ÄúSistema de chat‚Äù como epic ‚Üí historias: enviar mensaje, historial, notificaciones.
* Grooming de backlog: refinamiento de tickets para aclarar requisitos, estimar esfuerzo y priorizar.
* Herramientas: Jira, Linear, ClickUp.

#### d) Testing y calidad

* **Tipos de pruebas**: unitarias, integraci√≥n, E2E, carga, seguridad.
* Automatizaci√≥n: Cypress, Playwright, Selenium.
* Pruebas de seguridad: OWASP ZAP, Snyk, SonarQube.

#### e) Despliegue y CI/CD

* Integraci√≥n continua: GitHub Actions, GitLab CI, Jenkins.
* Despliegue continuo: pipelines automatizados que incluyen tests, builds y deploy a staging/prod.
* Contenedores: Docker y Kubernetes para consistencia entre ambientes.

#### f) Monitoreo y mantenimiento

* Monitoreo en tiempo real: Prometheus, Grafana, Datadog.
* Logging: ELK stack (Elasticsearch, Logstash, Kibana), Loki.
* Gesti√≥n de incidencias: Jira Service Management, PagerDuty.

#### 2. Metodolog√≠as √°giles y t√©cnicas modernas

El desarrollo √°gil permite iteraciones r√°pidas y entrega de valor continuo. Las metodolog√≠as m√°s usadas incluyen Scrum, Kanban y desarrollo iterativo, con soporte de **herramientas y t√©cnicas recientes**.

#### a) Scrum

* Trabajo en **sprints de 2‚Äì4 semanas**.
* Roles formales: Product Owner, Scrum Master, Developers.
* Ceremonias: Planning, Daily Stand-up, Review, Retrospective.
* Herramientas: Jira, ClickUp, Miro.
* T√©cnicas recientes:

  * *Planning Poker*: estimaciones colaborativas usando t√©cnicas de gamificaci√≥n.
  * *Definition of Done*: checklist que asegura que cada historia cumpla todos los criterios de calidad.
  * Integraci√≥n con IA: Copilot sugiere boilerplate de c√≥digo, pruebas unitarias o documentaci√≥n de endpoints.

#### b) Kanban

* **Flujo continuo**, no sprints fijos.
* Tablero visual: columnas To Do ‚Üí In Progress ‚Üí Done.
* L√≠mite WIP (Work in Progress) para optimizar throughput.
* M√©tricas: tiempo de ciclo, tiempo de espera, throughput, acumulado de trabajo.
* Herramientas: Trello, Jira Kanban Boards, Notion Boards.

#### c) Desarrollo iterativo

* Cada iteraci√≥n entrega una versi√≥n funcional parcial que se retroalimenta con feedback del cliente.
* Herramientas modernas: Figma (UI/UX r√°pido), Supabase (backend r√°pido), GitHub Actions (CI/CD).

#### d) Pair Programming

* Dos desarrolladores trabajan en el mismo c√≥digo: driver (escribe) y navigator (revisa y piensa estrategia).
* Herramientas: VSCode Live Share, CodeTogether, Tuple.

#### e) IA en desarrollo √°gil

* Aplicaciones: generar c√≥digo, pruebas, documentaci√≥n, refactorizaciones.
* Limitaciones: no reemplaza comprensi√≥n de negocio, puede generar vulnerabilidades o errores l√≥gicos.
* Plataformas: GitHub Copilot, ChatGPT, Replit Ghostwriter, TabNine.
* Buen uso: asistente de productividad, no reemplazo del desarrollador.

### 3. Ejemplo pr√°ctico: App de citas basada solo en texto y chat

#### a) Dise√±o

* Arquitectura:

  * Backend: Node.js + Express + Supabase (DB, autenticaci√≥n, storage).
  * Frontend: React Native (mobile) + Figma mockups.
  * Motor de matching: NLP con spaCy o Transformers para comparar intereses textuales.
  * Ticketing: Jira ‚Üí epic ‚ÄúSistema de chat‚Äù, stories: enviar mensajes, historial, notificaciones en tiempo real.

#### b) Desarrollo

* Supabase: crea endpoints autom√°ticos para CRUD de usuarios y chats, autenticaci√≥n lista para usar.
* GitHub Copilot: acelera escritura de endpoints, funciones y pruebas.

#### c) Testing

* Unit: Jest (Node.js), React Testing Library (frontend).
* E2E: Cypress para flujos de chat completos.
* Seguridad: OWASP ZAP y Snyk para an√°lisis de vulnerabilidades.

#### d) Stage y Producci√≥n

* Stage: despliegue temporal con datos simulados.
* Producci√≥n: Docker + Kubernetes, monitorizaci√≥n Prometheus/Grafana.

#### e) CI/CD

* Pipeline: Push ‚Üí tests ‚Üí build ‚Üí deploy staging ‚Üí revisi√≥n manual ‚Üí deploy prod.


### 4. Dise√±o de equipos y combinaciones de roles

#### a) Adaptaci√≥n de open source

* Roles: 2 backend, 1 QA, 1 DevOps, 1 Product Owner.
* T√©cnicas: feature branching, code review, CI/CD.
* Herramientas: GitHub, Jira, Supabase para prototipado r√°pido y pruebas.

### b) Desarrollo from scratch

* Roles: 2 backend, 2 frontend, 1 QA automation, 1 DevOps, 1 Scrum Master, 1 Product Owner.
* Herramientas: Jira, Figma, Supabase, Docker, GitHub Actions.
* T√©cnicas: Scrum, pair programming, sprints de 2 semanas, AI-assisted code.


#### 5. Roles dentro del proyecto

| Rol           | Nombre     | Responsabilidad principal    | Herramientas               |
| ------------- | ---------- | ---------------------------- | -------------------------- |
| Product Owner | Laura M.   | Define backlog, prioridades  | Jira, Notion               |
| Scrum Master  | Diego R.   | Facilita Scrum, bloqueos     | Jira, Miro                 |
| Backend Dev   | Sof√≠a T.   | API, DB, l√≥gica de negocio   | Node.js, Supabase          |
| Backend Dev   | Andr√©s V.  | Integraciones, scripts DB    | Supabase, GitHub           |
| Frontend Dev  | Camila P.  | UI m√≥vil, componentes        | React Native, Figma        |
| QA Automation | Luis F.    | Tests unitarios, integraci√≥n | Cypress, Playwright        |
| DevOps        | Valeria C. | CI/CD, staging/prod          | GitHub Actions, Docker/K8s |
| UX Designer   | Esteban L. | Flujos y experiencia usuario | Figma, Miro                |


## üéØ Ejercicio #1

**Escenario:** Mercado de trueque digital con chat entre usuarios. Imaginemos una plataforma web y m√≥vil que permite a los usuarios ofrecer y solicitar productos o servicios a cambio de otros, sin usar dinero. El objetivo es facilitar el trueque de manera segura, √°gil y organizada, con comunicaci√≥n directa entre usuarios mediante chat

**Tareas del grupo:**

1. Elegir Scrum o Kanban y justificar.
2. Crear un Epic y 3 tickets con descripci√≥n, criterios de aceptaci√≥n y asignaci√≥n.
3. Asignar roles
4. Mencionar una herramienta moderna para acelerar el desarrollo (ej: Supabase).

**Din√°mica:**

* 10 min ‚Üí discusi√≥n en grupos. El profesor armar√° los grupos aleatoriamente. 
* 5 min ‚Üí enviar resultados por medio del classroom




