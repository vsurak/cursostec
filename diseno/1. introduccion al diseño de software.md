## Qué es el diseño de software ##

### 1. Introducción al diseño de software

El profesor realizará una explicación magistral con dicha introducción, dejando claro con costos de dinero en dólares $ y tiempo, sobre el efecto que tienen las decisiones del diseño en las etapas tempranas y avanzadas de los proyectos de software. Se hace hincapié de la influencia del diseño cuando se negocian proyectos de software. 

El diseño de software es un proceso que se da una vez que se sabe "el qué", es decir, cuando se conoce lo que se quiere hacer, ya sea de un sistema, servicio, agente, proceso, integración, aplicación, solución de infraestructura, dispositivo o cualquier otro saber donde se requiera construir un algo, este puede ser digital, físico o ambos. 

Por eso siempre nuestra primer misión debe ser clarificar el qué. Proceda a realizar preguntas que le permita clarificar lo que se quiere hacer en los siguientes use cases:

tips:
- cómo va a funcionar el sistema
- que se desea del sistema finalmente
- cuál es la ganancia de la empresa con el sistema
- cómo se vería el sistema visualmente, UI - ideas
- equipo o la forma en que se podría poner a funcionar
- cómo lo acceden
- sistemas operativos, lenguajes de programación, bases de datos
- estretegias que se deben seguir para resolver el problema


a) En la fila: BigMoney es una empresa financiera que quiere tener en todas sus sucursales un sistema para quitar las filas de atención, en su lugar, las personas al llegar a una sucursal o bien desde sus teléfonos previamente, pueden tomar una ficha según el tipo de trámite que deseen hacer, de esa forma puedan ser llamadas en orden sin estar haciendo filas.


b) Venta de sandwiches: Prensaditos es una tienda de sandwiches que siempre ha vendido sus sandwiches por medio de una caja registradora en la ventanita física, atentiendo pedidos de express por teléfono, whatsapp y uber eats  recientemente. En palabras de uno de los dueños "nuestros sandwiches se han vuelto tan famosos en toda la zona, que es el momento de crecer para hacer llegar nuestros sandwiches a más lugares y para ello, no podemos seguir sin un sistema que nos agilice las órdenes por medio de todos nuestros canales de venta"


Existen macro componentes que pueden diseñarse en una solución de software, como por ejemplo:
- Frontend
- Backend
- Estrategias de seguridad
- Bases de datos
- Recursos on premises
- Recursos cloud
- Recuperación ante fallas
- Servicios 
- Procesos en background
- Integraciones a terceros
- CI/CD
- Proceso de desarollo y delivery
- Análisis de riesgos
- Documentación
- Comunicación 


Para diseñar soluciones de software los ingenieros nos valemos de modelos, es decir, representaciones o abstraciones que nos sirvan de mapa o guía del cómo es que se quiere lograr fabricar una solución. Para lograr hacer esos modelos es necesario que desarrollemos destrezas y conocimiento en varias técnicas de diseño que aplican a la construcción de prácticamente cualquier sistema de software, las cuales vamos a abordar a continuación. 

---

### 2. Diseño de classes y patrones de diseño

El diseño de clases es uno de los procesos más fundamentales en el desarrollo de software, 

El tema de patrones de diseño para programas orientados a objetos se abordan desde el curso de programación orientada a objetos, estructuras de datos, análisis de algoritmos y otros. Se recomienda repasar dichos diseños que son fundamentales para la implementación de frontend y backends. 

[Patrones de Diseño](https://refactoring.guru/design-patterns)


**Patrones Creacionales:**
- Singleton
- Abstract Factory
- Builder

**Patrones estructurales**
- Adapter
- Facade
- Bridge
- Decorator
- Proxy

**Patrones de Behavior**
- Observer
- Visitor
- Strategy
- Chain of responsability
- Mediator
- Dependency injection: 
 
[Understanding Dependency Injection](https://medium.com/@sardar.khan299/understanding-dependency-injection-a-powerful-design-pattern-for-flexible-and-testable-code-5e1161dd37dd) 


[Dependency Injection Example](src/dependencyinjection)

---
### 3. Diseño de la seguridad de un software

#### Authentication 

Cuando hablamos de autenticación, estamos hablando del procedimiento que se sigue para identificar quién es la persona o el sistema que está interactuando con otro sistema. Cómo me garantizo que es quién dice ser.

Este diseño se sugiere que debe tener al menos 2 cosas del triángulo de la seguridad: 

a) algo que se sabe : una clave, un pin, password.

b) algo que se posee : un token, una llave, una tarjeta, un chip

c) algo que se es : huellas dactilares, reconocimiento facial, iris del ojo, adn

La autenticación básica es basada en usuario y password, sin embargo, este esquema ha sufrido muchos ataques lo cual ha llevado a la industria a crear mecanismos que refueren el proceso de autenticación.

*Token-Based Authentication* 

Token-based authentication is a popular approach for securing applications and APIs. It involves issuing a token to a client (such as a user or an application) upon successful validation of credentials. The client then includes this token in subsequent requests to access protected resources.

![Image](./images/tokenauth.jpg)

User Authentication: 

- The user logs in using their credentials (e.g., username and password).
- The server validates the credentials and generates a token.
- This token represents the user’s identity and permissions.

Token Issuance: 

- The server issues a token (usually a JSON Web Token or JWT) to the client.
- The token contains claims (information) about the user, such as their user ID, roles, and expiration time.
- The token is digitally signed to ensure its integrity.

Token Storage: 

- The client (e.g., a web browser or mobile app) stores the token securely (e.g., in local storage or a cookie).

Subsequent Requests: 

- When the client makes requests to protected resources (e.g., APIs or routes), it includes the token in the request headers (usually as an “Authorization” header).
- The server verifies the token’s signature and decodes its claims.
- If the token is valid and not expired, the server grants access to the requested resource. 

*Multi factor or Two factor authentication*

Something You Know: This is typically a password or a response to a security question.
Something You Own: It could be a smartphone app (like Microsoft Authenticator) that generates verification codes or a physical token-generating device.
Something You Are: Usually a biometric trait like a fingerprint or face scan.

![Image](./images/2fa-diagram.png)

*OAuth 2.0*  

is an essential protocol for securing applications and APIs. I’ll break it down in a similar manner:

![Image](./images/oauthdiagram.png)

_Roles:_

- Resource Owner: The end-user who can grant access to protected resources.
- Resource Server: Hosts the protected resources (usually an API).
- Client: Represents the application requesting access on behalf of the Resource Owner.
- Authorization Server: Authenticates the Resource Owner and issues access tokens.

_Grant Types (Flows):_

- Authorization Code Flow: Used by web apps (executing on a server) and mobile apps (with Proof Key for Code Exchange, PKCE).
- Implicit Flow with Form Post: For JavaScript-centric apps (Single-Page Applications) executing in the user’s browser.
- Resource Owner Password Flow: Trusted apps (not recommended for public clients).
- Client Credentials Flow: For machine-to-machine communication.

_Endpoints:_
- /authorize: Initiates the authorization process.
- /oauth/token: Exchanges authorization code or credentials for an access token. 


Resumen:

![Image](./images/authentication%20design.gif)


#### Authorization

La autorización tiene que ver con determinar si la tarea o acción que quiere hacer el usuario o sistema identificado, tiene permitido o no realizar, y como otorgar el mínimo de privilegios posible a dicho usuario o sistema para que esté limitado a solo lo necesario para realizar una tarea. 

*Role-Based Access Control (RBAC)* 

RBAC authorizes and restricts system access based on user roles within an organization.

- Role Assignment: Users are assigned specific roles (e.g., admin, manager, employee). 

- Role Authorization: Active roles must be authorized. 

- Permission Authorization: Users can only exercise permissions authorized for their active role. 

- Benefits: Efficient, scalable, and minimizes unauthorized access. 


*Access Control Lists (ACL):* 

ACL specifies permissions for individual users or groups on specific resources.

- Each resource has an associated list of users/groups and their allowed actions.
- Fine-grained control over access (read, write, execute).
- Benefits: Granular control but can become complex to manage.

*Policy-Based Access Control (PBAC):* 

PBAC determines access dynamically based on rules and policies. 

- Policies define conditions for access (e.g., time of day, location, user attributes).
- Access decisions made at runtime based on policy evaluation.
- Benefits: Flexible, adaptable, and context-aware.


#### Exception Handling
El manejo de excepciones es una parte crítica del desarrollo de software robusto. Un mal manejo puede causar caídas, fugas de información sensible o una experiencia de usuario deficiente. Este documento resume buenas prácticas para:

* Manejar errores sin comprometer la estabilidad del sistema.
* Ocultar mensajes de error al usuario final.
* Loguear adecuadamente los errores para seguimiento.
* Asegurar que el sistema continúe ejecutándose incluso tras errores.

**Buenas prácticas generales** 

1. **Nunca mostrar errores técnicos al usuario final**: Siempre retorna un mensaje genérico como *"Ocurrió un error, por favor intente más tarde."*
2. **Usar bloques `try-catch` selectivos**: No envolver todo el código en `try-catch`. Solo donde hay riesgo real de error.
3. **Loguear siempre los errores internos**: Usa un sistema de logs como `winston` (Node), `logback` (Java) o `logging` (Python).
4. **Clasifica los errores**: Divide entre errores esperados (ej: usuario no autenticado) y errores inesperados (ej: null pointer, fallos de red).
5. **Evita silenciosamente ignorar excepciones**: Siempre registra o maneja adecuadamente.
6. **Centraliza el manejo de errores si es posible**: Especialmente en frameworks modernos que soportan middleware o interceptores.



**Angular - interceptor para ocultar errores y loguear**

```typescript
import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { ErrorService } from './error.service'; // Tu servicio de logs

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  constructor(private errorService: ErrorService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        this.errorService.log(error); // Guarda el log internamente o envíalo a backend
        alert('Algo salió mal. Intenta de nuevo.'); // Mensaje genérico
        return throwError(() => error); // Mantener trazabilidad para debugging
      })
    );
  }
}
```


**Manejo global de excepciones -- Java (Spring Boot) - microservicio resiliente**

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception ex) {
        LoggerFactory.getLogger(getClass()).error("Error inesperado", ex);
        return new ResponseEntity<>("Error interno, intente más tarde.", HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<String> handleBadRequest(BadRequestException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }
}
```

**Servicio con try-catch para resiliencia**

```java
@Service
public class UserService {

    public Optional<User> findByIdSafe(Long id) {
        try {
            return Optional.of(userRepository.findById(id).orElseThrow());
        } catch (NoSuchElementException e) {
            LoggerFactory.getLogger(getClass()).warn("Usuario no encontrado: " + id);
            return Optional.empty(); // Devuelve estado controlado
        } catch (Exception ex) {
            LoggerFactory.getLogger(getClass()).error("Error al buscar usuario", ex);
            return Optional.empty();
        }
    }
}
```

**Python Backend (Flask) - Error handler global**

```python
from flask import Flask, jsonify
import logging

app = Flask(__name__)
logging.basicConfig(level=logging.ERROR)

@app.errorhandler(Exception)
def handle_exception(e):
    app.logger.error("Unhandled exception: %s", str(e))
    return jsonify(error="Error interno del servidor"), 500
```

**Función segura con manejo de errores**

```python
def get_user_by_id(user_id):
    try:
        user = db.find_user(user_id)
        if not user:
            raise ValueError("Usuario no encontrado")
        return user
    except ValueError as ve:
        logging.warning(f"Advertencia: {ve}")
        return None
    except Exception as ex:
        logging.error(f"Error crítico: {ex}")
        return None
```


**Estrategias comunes** 


| Estrategia              | Descripción                                                                  |
| ----------------------- | ---------------------------------------------------------------------------- |
| **Try/Catch local**     | Controla el fallo específico sin afectar toda la app.                        |
| **Valores por defecto** | Devuelve resultados válidos aún ante fallo (ej: listas vacías).              |
| **Colas de errores**    | En sistemas distribuidos, envía a Dead Letter Queue.                         |
| **Circuit Breakers**    | En microservicios, para detener temporalmente llamadas a servicios fallando. |
| **Retry Policies**      | Reintentar ciertas operaciones (ej: redes) bajo reglas.                      |
| **Fallbacks**           | Alternativa funcional si algo falla.                                         |
| **Logs estructurados**  | Para poder analizar y tomar decisiones automatizadas.                        |


#### Monitor, Audit, Logs

El monitoreo y logging son fundamentales para mantener un software **estable, auditable, mantenible y confiable**. Permiten:

* Detectar **fallas en tiempo real**.
* Auditar operaciones de usuarios y cambios críticos.
* Diagnosticar errores complejos o intermitentes.
* Medir uso, rendimiento y comportamientos del sistema.
* Anticipar problemas antes de que impacten al usuario.


**¿Cómo se usan los logs?** 

| Objetivo                | Ejemplo                                                          |
| ----------------------- | ---------------------------------------------------------------- |
| **Auditoría**           | Registro de accesos, operaciones financieras, cambios en cuentas |
| **Errores**             | Excepciones, fallos de integración, timeouts                     |
| **Métricas**            | Tiempo de respuesta, número de solicitudes, carga por endpoint   |
| **Alertas automáticas** | Notificaciones en caso de errores 500, picos de uso, etc.        |
| **Cumplimiento legal**  | Retención de registros por normativas (ej. GDPR, HIPAA)          |



**Buenas prácticas de logging**

1. **Loguear en múltiples niveles**: info, debug, warn, error, fatal.
2. **Estructurar los logs** (JSON o campos clave): evita logs planos.
3. **No loguear datos sensibles**: como contraseñas o tarjetas.
4. **Incluir contexto**: ID de usuario, IP, endpoint, timestamp, etc.
5. **Correlación de logs**: usa `requestId` o `traceId` o `referenceid` algún id que haga relación.


**Ejemplo en .NET (C#) usando `Serilog`**

```csharp

using Serilog;

var builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog((ctx, lc) => lc
    .WriteTo.Console()
    .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day)
    .Enrich.FromLogContext()
    .Enrich.WithProperty("Application", "MyApp"));

var app = builder.Build();

app.MapGet("/user/{id}", (int id) => {
    Log.Information("Buscando usuario {UserId}", id);
    try {
        if (id == 0) throw new Exception("ID inválido");
        return Results.Ok(new { id });
    } catch (Exception ex) {
        Log.Error(ex, "Error al buscar usuario");
        return Results.Problem("Error interno");
    }
});

app.Run();
```

**Ejemplo en Node.js + TypeScript usando `winston`**

```ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
  ],
});
```

```ts
import express from 'express';
import { logger } from './logger';

const router = express.Router();

router.get('/user/:id', (req, res) => {
  const userId = req.params.id;
  logger.info(`Request for user ${userId}`, { userId });

  try {
    if (userId === '0') throw new Error('Invalid user ID');
    res.json({ userId });
  } catch (err) {
    logger.error('Error fetching user', { error: err.message });
    res.status(500).json({ message: 'Internal error' });
  }
});

export default router;
```


**¿Cómo funciona AWS CloudWatch?** 
Es el sistema de observabilidad de Amazon. Permite:

* Recibir logs de aplicaciones y servicios (EC2, Lambda, ECS, etc).
* Crear **dashboards y métricas personalizadas**.
* Definir **alarmas y alertas** automáticas.
* Integrarse con otras herramientas como SNS, EventBridge y Lambda.

**Componentes clave de CloudWatch:**

| Componente     | Descripción                                         |
| -------------- | --------------------------------------------------- |
| **Logs**       | Almacena logs de apps y servicios                   |
| **Metrics**    | Datos numéricos como uso de CPU, errores, latencia  |
| **Alarms**     | Disparadores ante condiciones (ej: > 5 errores/seg) |
| **Dashboards** | Visualización de métricas y estado                  |
| **Insights**   | Consulta y análisis avanzado de logs                |

Todos los proveedores de cloud services ofrecen algun servicio para logs, se comportan todos muy similar. 

Otros productos especializados en logging y monitoreo :

Claro, aquí tienes la tabla de productos especializados en logging y monitoreo, **sin la columna de capturas**:

| Producto         | Función destacada                                                                                                                                                              |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Datadog**      | Plataforma todo en uno para métricas, logs, trazas, APM y monitoreo de infraestructura. Permite dashboards en tiempo real y alertas configurables.                             |
| **ELK Stack**    | Conjunto de herramientas (Elasticsearch, Logstash, Kibana) para ingestión, búsqueda y visualización avanzada de logs. Muy usado en arquitecturas on-premise y cloud.           |
| **Grafana Loki** | Sistema de agregación de logs altamente escalable e integrado con Grafana. Permite consultas estructuradas tipo PromQL sobre logs.                                             |
| **Sentry**       | Especializado en monitoreo de errores con trazabilidad hasta la línea de código. Muy usado en frontend y backend para detectar fallos específicos.                             |
| **New Relic**    | Observabilidad full stack con trazas distribuidas, análisis de rendimiento, errores, logs, y métricas de negocio. Fácil de integrar con múltiples lenguajes y servicios cloud. |


### 4. Diseño del SDLC, software developent life cycle 

- explicar lo que normalmente se documenta en un SDLC
- explicar de opciones para organizar agile, desarrollo iterativo, pair programaing
- tomar en cuenta procesos de diseño, desarollo, testing, stage, subir a produccion, ci/cd
- como se hace para diseñar y presentar los equipos de trabajo que trabajaran el proyecto
- roles dentro del proyecto 


