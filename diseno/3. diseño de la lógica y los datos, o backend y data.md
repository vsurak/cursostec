# Capa de acceso a datos en una arquitectura

La capa de acceso a datos (Data Access Layer, DAL) es el componente de una arquitectura de software responsable de interactuar directamente con el sistema de almacenamiento persistente, generalmente una base de datos. Su función principal es abstraer la lógica de persistencia, permitiendo que las capas superiores (como la lógica de negocio o la interfaz de usuario) trabajen con objetos o estructuras de datos sin preocuparse por los detalles de cómo se almacenan o recuperan. Esta capa encapsula operaciones como consultas SQL, inserciones, actualizaciones, y eliminaciones, y puede incluir mecanismos de mapeo objeto-relacional (ORM), validaciones, y transformaciones de datos.

Una DAL bien diseñada promueve el desacoplamiento, facilita pruebas unitarias, y permite cambiar el motor de base de datos o el modelo de persistencia sin afectar el resto de la aplicación. Además, centraliza el manejo de errores, la gestión de conexiones, y las políticas de seguridad relacionadas con el acceso a los datos.

## Motores de bases de datos

Un motor de base de datos es el software responsable de almacenar, recuperar, modificar y administrar datos en una base de datos. Es el núcleo que interpreta las instrucciones (como sentencias SQL), gestiona la concurrencia, asegura la integridad de los datos, y optimiza el rendimiento de las operaciones. El motor puede ser parte de un sistema de gestión de bases de datos (DBMS) más amplio, que incluye herramientas de administración, interfaces de usuario, y conectores para lenguajes de programación.

Los motores de base de datos pueden operar en memoria, en disco, o en entornos distribuidos, y su elección impacta directamente en la escalabilidad, velocidad, y confiabilidad del sistema. También hoy día existen lo que se llaman clusters, data warehouses, data lakes y modelos. 

Existen varios tipos de motores de bases de datos, cada uno con características específicas:

- **Relacionales (RDBMS)**: Basados en tablas con relaciones entre ellas. Usan SQL como lenguaje principal. Ejemplos: MySQL, PostgreSQL, SQL Server, Oracle.

- **NoSQL**: Diseñados para datos no estructurados o semiestructurados. Incluyen modelos clave-valor, documentos, grafos y columnas. Ejemplos: MongoDB, Redis, Cassandra, Neo4j. 

- **En memoria**: Optimizados para velocidad, almacenan datos directamente en RAM. Ejemplo: Redis. 

- **Distribuidos**: Diseñados para escalar horizontalmente en múltiples nodos. Ejemplo: CockroachDB, Amazon Aurora.

- **Orientados a grafos**: Especializados en representar relaciones complejas entre entidades. Ejemplo: Neo4j. 


## Lo crítico del diseño de la base de datos en la arquitectura

El diseño de la base de datos es uno de los pilares más críticos en la arquitectura de software. Una base mal diseñada puede generar cuellos de botella, inconsistencias, duplicidad de datos, y dificultades para escalar. Por el contrario, un diseño bien estructurado permite consultas eficientes, integridad referencial, y facilidad para evolucionar el sistema.

Aspectos como la normalización, el uso adecuado de índices, la definición clara de claves primarias y foráneas, y la separación lógica de entidades son fundamentales. Además, el diseño debe alinearse con los casos de uso reales del sistema, anticipando patrones de lectura, escritura, y crecimiento de datos. En arquitecturas modernas, el diseño también debe considerar la compatibilidad con microservicios, replicación, y tolerancia a fallos.


## Seguridad en el diseño de una base de datos

La seguridad en el diseño de bases de datos no puede ser una ocurrencia tardía; debe estar integrada desde el inicio. Algunos aspectos clave incluyen:

- **Control de acceso**: Definir roles y permisos granulares para usuarios, evitando privilegios innecesarios. 

Role-Based Permissions: 

**Definición**  
Los permisos basados en roles permiten asignar privilegios a grupos de usuarios según su función dentro de la organización (por ejemplo, administrador, analista, auditor). En lugar de asignar permisos directamente a cada usuario, se asignan a roles, lo que facilita la gestión y el cumplimiento de políticas de seguridad.

Supongamos que tienes tres tipos de usuarios: `LoanManagers`, `Auditors`, y `SupportStaff`. 

```sql
-- Crear roles
CREATE ROLE LoanManagers;
CREATE ROLE Auditors;
CREATE ROLE SupportStaff;

-- Asignar permisos al rol LoanManagers
GRANT SELECT, INSERT, UPDATE ON prestamos TO LoanManagers;

-- Asignar permisos al rol Auditors (solo lectura)
GRANT SELECT ON prestamos TO Auditors;

-- Asignar permisos al rol SupportStaff (solo clientes)
GRANT SELECT ON clientes TO SupportStaff;

-- Agregar usuarios a roles
EXEC sp_addrolemember 'LoanManagers', 'usuario1';
EXEC sp_addrolemember 'Auditors', 'usuario2';
EXEC sp_addrolemember 'SupportStaff', 'usuario3';
```

**Ventajas**  
- Escalabilidad en la administración de usuarios.
- Separación clara de responsabilidades.
- Cumplimiento más fácil de normativas como GDPR o ISO 27001.


Row-Level Security (RLS): 

**Definición**  
Row-Level Security permite definir reglas que restringen el acceso a filas específicas dentro de una tabla, según el contexto del usuario. Esto es útil cuando múltiples usuarios acceden a la misma tabla pero deben ver solo los datos que les corresponden.

Supongamos que cada usuario solo puede ver los préstamos que él mismo gestiona. Primero, necesitas una tabla que relacione usuarios con clientes:

```sql
-- Tabla de asignación de clientes a usuarios
CREATE TABLE cliente_usuario (
    clientid INT,
    username NVARCHAR(100)
);
```

Luego, defines una función de seguridad:

```sql
CREATE FUNCTION dbo.fn_cliente_rls(@username AS NVARCHAR(100))
RETURNS TABLE
WITH SCHEMABINDING
AS
RETURN SELECT clientid FROM dbo.cliente_usuario WHERE username = @username;
```

Y aplicas la política de seguridad:

```sql
CREATE SECURITY POLICY cliente_rls_policy
ADD FILTER PREDICATE dbo.fn_cliente_rls(USER_NAME()) ON dbo.prestamos
WITH (STATE = ON);
```

**Resultado**  
Cuando un usuario consulta la tabla `prestamos`, solo verá los registros asociados a los `clientid` que le corresponden según la tabla `cliente_usuario`. 

**Ventajas**  
- Seguridad granular sin modificar la lógica de aplicación.
- Reducción de errores humanos en la gestión de permisos.
- Auditoría más precisa del acceso a datos sensibles.

- **Encriptación**: Aplicar cifrado en reposo (datos almacenados) y en tránsito (datos transmitidos).

- **Auditoría**: Registrar operaciones sensibles como accesos, modificaciones y eliminaciones. 

- **Validación de entradas**: Evitar inyecciones SQL mediante parámetros preparados y sanitización.

- **Seguridad física y de red**: Asegurar que el servidor de base de datos esté protegido contra accesos no autorizados y ataques externos.


## Cómo sucede una conexión a la base de datos: Stateless, Stateful y punto a punto

Cuando una aplicación se conecta a una base de datos, establece un canal de comunicación que puede ser gestionado de distintas formas:

- **Stateless**: Cada operación se realiza en una conexión independiente, sin mantener estado entre llamadas. Es común en arquitecturas RESTful y escalables, donde el servidor no guarda contexto. Aunque más escalable, puede ser menos eficiente si se requiere mantener sesión o transacciones largas. 

- **Stateful**: La conexión mantiene estado entre múltiples operaciones. Esto permite transacciones, sesiones persistentes, y operaciones encadenadas. Es útil en sistemas que requieren consistencia fuerte o lógica compleja, pero puede dificultar la escalabilidad horizontal. 

- **Conexión punto a punto**: Se refiere a una conexión directa entre la aplicación y la base de datos, sin intermediarios. Es común en sistemas monolíticos o de escritorio. Aunque simple, puede ser riesgosa en entornos distribuidos o públicos, donde se recomienda usar proxies, firewalls o capas intermedias. 

En arquitecturas modernas, se suele usar **pools de conexiones** para reutilizar conexiones abiertas y mejorar el rendimiento, especialmente en entornos web de alta concurrencia. 

Un **pool de conexiones** es un conjunto de conexiones a la base de datos que se mantienen abiertas y disponibles para ser reutilizadas por múltiples solicitudes. En lugar de abrir y cerrar una conexión por cada operación (lo cual es costoso en términos de tiempo y recursos), el pool gestiona las conexiones activas y las distribuye según demanda. 

Esto es especialmente útil en aplicaciones web, donde múltiples usuarios pueden generar cientos o miles de solicitudes simultáneas. Sin un pool, el sistema podría saturarse rápidamente por la sobrecarga de creación y destrucción de conexiones. 

Imagina una aplicación Java que sirve como backend para una plataforma de préstamos. Cada vez que un usuario consulta su saldo, realiza un pago o solicita un nuevo préstamo, el sistema necesita acceder a la base de datos MySQL. En horas pico, podrían generarse cientos de operaciones por minuto. 

Sin un pool, cada operación abriría una nueva conexión, lo que podría agotar los recursos del servidor o del motor de base de datos. Con un pool, las conexiones se reutilizan, se limitan, y se gestionan de forma eficiente. 

Ejemplo 1: Pool de tamaño fijo 

```java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/mi_base");
config.setUsername("usuario");
config.setPassword("clave");

// Pool de tamaño fijo: 10 conexiones
config.setMaximumPoolSize(10);
config.setMinimumIdle(10);
config.setIdleTimeout(30000); // 30 segundos

HikariDataSource dataSource = new HikariDataSource(config);

// Uso de conexión
try (Connection conn = dataSource.getConnection()) {
    PreparedStatement stmt = conn.prepareStatement("SELECT * FROM prestamos");
    ResultSet rs = stmt.executeQuery();
    // Procesar resultados...
}
```

Ejemplo 2: Pool dinámico (crece y se autoreduce)

```java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/mi_base");
config.setUsername("usuario");
config.setPassword("clave");

// Pool dinámico: mínimo 5, máximo 20
config.setMinimumIdle(5);
config.setMaximumPoolSize(20);
config.setIdleTimeout(60000); // 1 minuto
config.setMaxLifetime(1800000); // 30 minutos

HikariDataSource dataSource = new HikariDataSource(config);

// Uso de conexión igual que antes
```

### Ejercicio #3 - diseño de modulo de tiempos

Proceda a hacer el diseño de base de datos en un motor relacional de su gusto, para un sistema de venta de tiempos. Estos tiempos se venden interncionalmente, es decir, que cualquier persona del país donde exista la aplicación disponible puede comprar el número que quiera. Existe un registro de usuarios, y cada usuario decide el número que quiere comprar y el monto que quiere poner a ese número. Existen sorteos semanales y sorteos extraordinarios, los usuarios "apuestan" a numeros segun el sorteo. No hace falta que diseñe tablas de resultados, o premios. Lo que si se necesita, es que diseñe los métodos de pago que hay disponibles por país y que cada método de pago sea configurable la forma en que se llama al API del método. 

Una vez que tenga el diseño listo, proceda a insertar por medio de un script al menos 1000 registros de alguna tabla. 

Debe entregar el diseño como PDF y el script SQL.


### Ejercicio #4 - implementando un pool y una cache
-- pending


---
## Descisiones que se deben tomar en el diseño de la capa de datos

### **estructural - infraestructura, arquitectura de hardware, devops, dataops**

a) la topología de los datos, si se trata de OLTP, maestro/esclavo, base de datos distribuida, base de datos replicada, geo distribuidas 

b) si se trata de un repositorio de big data como hive, fabric, bigtable, snowflake, hadoop, data lakes, data marts o cualquier integración para este tipo de procesamiento de gran escala 

c) si usar un motor de base de datos relacional o documental tipo nonSQL 

d) el tenancy y permiso de acceso de los datos, la privacidad, protección y seguridad de los datos como último punto de defensa de los sistemas 

e) el modelo y políticas para recuperación y tolerancia a fallas 

### **De diseno orientado a objetos - programación**

a) transaccional vía statements o stored procedures 

b) se va usar de ORM, parcial o 100%?

c) layers para control de conexiones, cocurrencia, mapeo de data a objetos y viceversa, modelos de objetos y data objects con su relación 

c) uso de pool de conexiones 

d) uso de cache 

e) drivers nativos e interpretados 

f) el diseño de los datos

g) costos de almacenamiento

h) archiving


