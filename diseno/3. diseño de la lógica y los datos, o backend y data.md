# Tecnologías, arquitecturas y tendencias del backend

## arquitecturas de alto nivel para la implementación de backends

### REST (Representational State Transfer)

REST is an architectural style for designing networked applications. It relies on stateless, client-server communication, usually over HTTP/HTTPS, and uses standard HTTP methods (GET, POST, PUT, DELETE, UPDATE) to operate on resources. Resources are identified by URLs, and the server provides responses in a variety of formats, such as JSON or XML.

REST requiere de un servidor que opera similar a un webserver, recibe un request de un resource y una operación, el servidor posee algún tipo de router que basado en ese request determina la función de alguna clase que deberá ser llamado, recibiendo por parámetro el request enviado y también habilitando un objeto response para enviar la respuesta en el formato configurado para cumplir con el protocolo stateless de http. 

- simple
- universal, allowing diversity of clients
- based on web technology
- decouple client and server layers
- usual for api development
- se puede implementar en prácticamente cualquier lenguaje sin embargo existen multiples frameworks para facilitar su implementación y para proveer facilitadores que se encarguen de manejar detalles de arquitecturas como timeouts, cantidad de conexiones, escalabilidad, threads, caches, sesiones y más
- le corresponde al arquitecto, equipo de ingenieros o la persona responsable de su implementación, de crear un diseño que obedezca a la estructura, organización y escalabilidad que la organización requiera
- on premise, cloud or on premise serverless/or cloud

### GraphQL
GraphQL is a query language and runtime for APIs that allows clients to request only the data they need. Unlike REST, which exposes fixed endpoints that return predefined data structures, GraphQL lets clients define the shape and size of the data in a single request. It also allows multiple resources to be fetched in a single query, reducing the number of network requests.

- efficient data retrieval, reducing over-fetching and under-fetching.
- strongly typed schema, providing clear API contracts.
- flexibility in evolving APIs without breaking clients.
- ofrece diferentes tipos de operaciones llamadas queries, mutations and subscriptions para crear toda la arquitectura de request response de graphql
- aún con esas ventajas, graphql requiere que se implementen resolvers para cada dataset que se quiera procesar, haciendo que los backends duren más tiempo en desarrollarse y que requieren un mantenimiento mayor para mantener esos resolvers actualizados con la capa de datos y en muchas cosas con los ORMs
- on premise, cloud or on premise serverless/or cloud

### Serverless Architecture
Serverless architecture allows developers to build and deploy applications without managing the underlying server infrastructure. In this model, cloud providers automatically manage the server resources, scaling them based on demand. Functions-as-a-Service (FaaS), like AWS Lambda or Azure Functions, are a common implementation of serverless architecture. Existen varios frameworks para la implementación de serverless, como por ejemplo https://www.serverless.com/, capaz de hacer deployment en la mayoría de los cloud services comerciales.

Las arquitecturas serverless van en extremo asociadas o de la mano con los cloud providers o con tecnologías contenerizadas o virtuales que permitan el alojamiento de recursos computacionales (CPU, Memory, Bus, Cache, Storage) en formá dinámica y elástica. Eso lleva consigo un problema de warnup que en algunos lenguajes suelen pagar un penalty muy alto en tiempo de respuesta. 

- Reduced operational complexity, as developers don't manage servers.
- Cost-efficiency, as billing is based on actual usage.
- Automatic scaling and high availability.
- on premise or cloud

### gRPC (gRPC Remote Procedure Calls)
A modern, high-performance, open-source framework for remote procedure calls (RPC) developed by Google. It uses Protocol Buffers (protobuf) for serialization and supports multiple languages.
Use Cases: Microservices communication, real-time services, and high-performance applications.

principalmente supported by Go, Java, C++, python, C#, nodejs and available in azure, aws, digital ocean, gcp

```
message User {
    int32 id = 1;
    string name = 2;
    string email = 3;
}

service UserService {
    rpc GetUserById(UserIdRequest) returns (UserResponse);
}

message UserIdRequest {
    int32 id = 1;
}

message UserResponse {
    User user = 1;
}
```

### Event-Driven Architecture (EDA)
A design architectural pattern in which decoupled components (producers and consumers) communicate asynchronously via events. This architecture is often implemented using message brokers like Kafka or RabbitMQ, there's a bunch of messaging systems, cloud services usually offers a native platform for this. It also requires an event listener in the client side. 

This architecture is very practical for Real-time applications, distributed systems, and microservices.

https://activitypub.rocks/


### Microservices Architecture
An architectural style that structures an application as a collection of loosely coupled services. Each service is independently deployable and communicates over a network. In many cases microservices are design using isolated services and databases, but such design can be adapt depending of the business case. 

Microservices is normally associate to too complex to manage, code and maintain because its purpose of loosely coupled services, but this can be easily interpreted under the eye of the conceptual design of the services and the intention of the microservices. Is deserible as a good pratice the main reason why the architect is looking for such kind of separation. 

Microservices frameworks are important to easy the implementation and maintenance of the services code. Spring Boot, Micronaut, NestJS, DJango + REST. 


This is ideas for large, complex applications that need to scale development and deployment independently.

### Monolithic Architecture
A traditional approach where the entire application is a single, unified unit. All components are tightly integrated and run as a single service. Ideal for small to medium-sized applications with simple requirements.

Ruby on Rails (RoR) se considera una arquitectura monolítica por defecto. En una arquitectura monolítica, todos los componentes de la aplicación, como la lógica de negocio, la capa de datos y la interfaz de usuario, están integrados en un único proyecto o aplicación que se ejecuta como una sola unidad.

*Características de Ruby on Rails en Arquitectura Monolítica:*

*_Convención sobre Configuración_*: Rails sigue el principio de "Convención sobre Configuración", lo que significa que toma muchas decisiones por defecto, permitiendo a los desarrolladores enfocarse más en la lógica de negocio que en la configuración.

*_MVC (Model-View-Controller)_*: Rails sigue el patrón de diseño MVC, donde:

- Model: Representa la lógica y estructura de la base de datos.
- View: Maneja la presentación de datos al usuario.
- Controller: Gestiona la interacción del usuario, invoca al modelo y selecciona la vista que se debe renderizar.

*_Integración Completa_*: Rails ofrece una solución integral que incluye el manejo de bases de datos, enrutamiento, controladores, vistas y la lógica de negocio en un solo marco, facilitando el desarrollo rápido y estructurado.


### API Gateway Architecture
API gateway sits between clients and backend services. It handles request routing, composition, protocol translation, and other cross-cutting concerns like authentication and rate limiting. Ideal for Microservices-based applications, where an API gateway can manage service interactions. Something important in api gateway architecture es la capacidad de ofrecer un único punto de entrada para multiples servicios implementados en múltiples tecnologías y protocolos de comunicación, seguridad, transporte y red. 


Luego de que se decide la topología arquitectónica de un backend, sigue la decisión de los componentes arquitectónicos que se le van a agregar a dicha topología y el stack de tecnologías.

## Componentes arquitectónicos y stack de tecnologías 

esta no es una decisión fácil, pues se debe diseñar a partir de la combinación de los requerimientos de negocio versus todos los componentes arquitectónicos versus el panteon de tecnologías existentes cuyas posiblidades, capacidades y limitaciones son amplias y cada una puede responder de mejor manera según el escenario donde se implemente. 

quien diseñe la arquitectura de software (el arquitecto talvez...) tiene la gran responsabilidad de juntar todos esos superpoderes para crear un diseño arquitectónico del backend que:
1. responde a los requerimientos del negocio
2. es capaz de solventar los requerimientos no funcionales: seguridad, recursos, escalabilidad, tolerancia a fallas, disponibilidad 
3. es costo efectiva
4. el impacto que va a tener en el equipo de desarrollo en general: software, diseño de software, devops, qa. el impacto puede ser en recurso humano, curva de aprendizaje, tiempo de desarrollo, tamaño del equipo, herramientas de qa y devops; tiene mucha incidencia incluso en la motivación del equipo de trabajo


## diseño de la capa de datos

en el diseño de la capa de acceso a datos hay múltiples descisiones que se deben tomar: 


### **estructural - infraestructura, arquitectura de hardware, devops, dataops**

a) la topología de los datos, si se trata de OLTP, maestro/esclavo, base de datos distribuida, base de datos replicada, geo distribuidas 

b) si se trata de un repositorio de big data como hive, fabric, bigtable, snowflake, hadoop, data lakes, data marts o cualquier integración para este tipo de procesamiento de gran escala 

c) si usar un motor de base de datos relacional o documental tipo nonSQL 

d) el tenancy y permiso de acceso de los datos, la privacidad, protección y seguridad de los datos como último punto de defensa de los sistemas 

e) el modelo y políticas para recuperación y tolerancia a fallas 


### **de diseno orientado a objetos - programación**

a) transaccional vía statements o stored procedures 

b) uso de ORM 

c) layers para control de conexiones, cocurrencia, mapeo de data a objetos y viceversa, modelos de objetos y data objects con su relación 

c) uso de pool de conexiones 

d) uso de cache 

e) drivers nativos e interpretados 

f) el diseño de los datos

## resumen de arquitecturas a alto nivel

![Image](./images/patronesdisenoarqui.gif)


## Week 8 

1. Revisión del ejercicio #4 - canal general

2. Ejecución del ejercicio #5 

Se van a realizar propuestas de como atacar los siguientes retos en el diseño de backends y de data. El profesor creará grupos de investigación aleatorios en la clase, los miembros buscaran alternativas para atacar dichos retos a la luz del caso #2. Cronograma del ejercicio: 

- 10 minutos para investigar alternativas
- 30 minutos, profesor entrevista cada miembro del grupo lo discutido
- Cada grupo expondrá la solución en 2 minutos


Retos: 

a) Si solo cuento con una base de datos y una cola, cómo podría implementar un patrón arquitectónico de pub/sub en un backend? 

b) Usando uno de los lenguajes de su backend, cómo podríamos atender 1000 solicitudes con 10 hilos de ejecución únicamente. 

c) cómo adecuar este patrón https://medium.com/@nouraldin.alsweirki/pub-sub-pattern-in-react-e1ea02cfdf96 a algún proceso ya sea en frontend o en backend? 

d) se necesita que cierta información de su sistema, la cual está en el motor de base de datos que previamente seleccionó, pueda ser leída desde un punto más cercano al país de donde se está accediendo, es decir, que la información este cerca del país de donde se consulta, cómo lo resuelve? 

e) Hay grupos de usuarios o roles que no tienen permiso de ver información de ciertas tablas en la base de datos, y además existen grupos o roles, que aunque puedan ver la información de la tabla, solo deben ver aquellos registros que son propios de su organizacion y no de otras organizaciones dentro del sistema. Cómo podría resolver estos tipos de permisos usando el motor de base de datos seleccionado ?



## Week 9 - holy week

## Week 9

- revisión del Ejercicio #5 

- Leer y analizar del libro "the-software-architect-elevator.epub", los capítulos capítulos 1,2,8,14,16,18,19. Evaluación en clase el miércoles 30 de abril. 

- llenar el siguiente template ejemplo para el caso 2 : 

Each decision must include:  
1. **Cloud service technology**  
2. **Object-oriented design patterns**  
3. **Class layers for data access**  
4. **Configuration policies/rules**  
5. **Expected benefits**  


a) la topología de los datos, si se trata de OLTP, maestro/esclavo, base de datos distribuida, base de datos replicada, geo distribuidas 

- lo que hay que documentar es los tipos y cantidad de bases de datos, por ejemplo:
"app asssistant consiste de una única base de datos en postgresql, hosted en RDS, el acceso deberá estar restringido por una VPC y un whitelist que permita conectar únicamente a los servicios desde AWS." 

- benefits: dado la técnica o tecnología seleccionada, cuáles son los beneficiones, ejemplo: 

- es open source, reduce costos de licencias
- support by AWS RDS
- benchmark de 10GB por minuto en X
- mongodb no emite errores ante información mal formada que no requiere almacenarse el 100% 


b) si se trata de un repositorio de big data como hive, fabric, bigtable, snowflake, hadoop, data lakes, data marts o cualquier integración para este tipo de procesamiento de gran escala 

- lo que se busca incluir en el diseño, es si la información de este sistema debe alimentar repositorios de datos de gran tamaño que se van a usar posteriormente para Ciencia de Datos o ML. 

Ejemplo: 

- no, no se estima para los siguientes años el uso de la data para ML o ciencia de datos.  

o 

- si, se va a requerir en el futuro un proceso de carga por lotes mensualmente a las 2am, a un datalake en snowflake para realizar análisis de comportamiento de los consumidores del app. 

- El servicio de snowflake va a usar de cloud provider a AWS
- Carga por lotes de los "deltas" mensualmente a partir de las 2am

delta = TotalRegistros - TotalRegistrosPasados; (un delta es la data que no se ha procesado aún)

Beneficios: 
- adopción temprana de ciencia de datos
- arquitectura del sistema nace alimentando un data repository para ciencia de datos 
- snowflake se puede utilizar en 3 diferentes cloud providers 
- snowflake se utiliza via SQL
- PowerBi y tableu que son las plataformas que se van a usar para análisis de datos se conectan de forma agnóstica a snowflake 


c) si usar un motor de base de datos relacional o documental tipo nonSQL 

Es la decisión del motor, casi que se tomó está decisión en el punto a) , podemos enfatizar.

- se hostead con RDS

Benefits: 

- el sistema es naturalmente transaccional por lo que debe mantener consistencia de datos
- transacciones "todo o nada" 

d) el tenancy y permiso de acceso de los datos, la privacidad, protección y seguridad de los datos como último punto de defensa de los sistemas 

Un ejercicio que podemos hacer para contestar esto, es imaginarnos que un atacante ya logró tener acceso a los datos, o simplemente aceptar esa posiblidad. Otras posibilidades que podrían aceptar es que hayan errores de programación que podrían exponer información que no le pertenece a un tenant, entonces la pregunta es, qué medidas tomo para evitar esto: 


Esta parte va o va, tenemos que identificar que requiere protección por cifrado y por hash: 

- hubo acceso a la base de datos: checksums, cifrado, hashes. Qué es lo que va ir cifrado en la base de datos. 


Ejemplo: 

- información a cifrar: 
    - información de contacto de las empresas 
    - la información de configuración de pagos para las membresías 
    - los emails de los usuarios 
    - sigo listando la información que debe ir cifrada 
    - todo password o pin hashed 
    - checksums en tablas de transacciones, pagos, logs, beneficios, etc 

Si, más de una compañía utiilzar mis servicios para operaciones propias, paso a ser un sistema multitenant y por ende debo garantizar que no se vean datos entre compañías (entre tenants): 

- riesgos de fallos por tenancy: en algunos casos se hace el tenancy por copia, en otros casos se hace el tenancy por copia de schema de la base de datos. Lo que se busca es que la información que le pertene a un tenant nunca esté física mezclada con la información de otro tenant; o sea que hice una transformación de mi sistema que es multitenant a ser de tenant único a nivel físico de los datos. 


- esto es típico reto de cualquier servicio SaaS 

- es mi sistema tenant o multitenant? app asistant es multitenant, porque hay varias empresas dentro del mismo sistema, hay riesgo de cross info. En el caso de payment assistant tengo un problema de multitenant en el caso de que empresas usen al sistema para el manejo automatizado de sus pagos. 

- una forma que siempre tiene riesgos para garantizar que un modelo multitenant no entregue información privada a otros tenant, es haciendo uuna capa de singletenant por software. Todos los servicios deben acceder solo por esta capa: 

Ejemplo: 
Strategy pattern y un builder para garantizar que todas las classes del layer de data access solo accedan a la DB por medio del layer de tenancymanager. 

Se restringe a todos los services a conectar con un single proxy y ese single proxy es el único autorizado a conectar con la DB (whitelist). 

beneficios : 

en el caso que me fui por copia:

- es imposible el cross data entre tenants 
- el rendimiento de un tenant no afecta el otro 
- escalabilidad individualizada 

en el caso de tenant manager layer: 
- reducción de costos de mantenimiento
- aprovechamiento de los recursos computacionales entre todos los tenant


e) el modelo y políticas para recuperación y tolerancia a fallas 


de diseno orientado a objetos - programación 

a) transaccional vía statements o stored procedures 

b) uso de ORM 

si o no, si es si, cual ORM?

c) uso de pool de conexiones 
si o no, si si, static o dinamic, cualquiera de los tamaño inicial, tasa de crecimiento, libreria de pool a usar. 

d) uso de cache 

si o no, 

si, cuál, qué tecnología, qué cosas van a cache. cuál va a ser la llave de esos items en cache, flushing criteria. 

e) drivers nativos e interpretados 

nativos: ado.net, jdbc, python binaries 
interpretados: todo lo demás. ODBC, Pipe.. 

f) el diseño de los datos 

que cosas quiero que los desarrolladores tengan claro como se va a diseñar, y ahi agrego ejemplos de esos diseños de las tablas. Solo de las partes clave. NO todo el diseño de la base de datos.  

en el caso que haya tambien base de datos no relacional, el ejemplo de diseño puede ser con json ejemplos. 


