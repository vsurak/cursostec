1. Temas de estudio para hacer ejercicio el viernes:

Del libro de navathe, sexta edici칩n, parte 9, cap 21, 22, 23, estudiar los siguientes temas:
- dirty read
- incorrect summary problem
- unrepeatable read problem
- two phase locking
- wait-die
- wound-wait
- timestamp ordering algorithm excepto multiversion
- write ahead logging, steal/no steal, force/no force
- distinguir cuando se requieren operaciones de REDO y cuando de UNDO


2. Algoritmo de Aries

3. En SQL Server, las tablas temporales pueden ser **f칤sicas** o **en memoria**. Aqu칤 te explico ambas:

**Tablas Temporales F칤sicas (`#temp`)**  
   - Se crean en **tempdb**, por lo que persisten durante la sesi칩n o hasta que se eliminen expl칤citamente.
   - Son 칰tiles cuando se manejan grandes vol칰menes de datos y se necesita acceso r치pido.

**Tablas Temporales en Memoria (`@tableVariable`)**  
   - Se almacenan en la memoria, lo que las hace m치s eficientes en operaciones peque침as.
   - No permiten 칤ndices no agrupados (excepto el `PRIMARY KEY`).
   - Son mejores cuando se manejan pocos registros y se evita la sobrecarga de `tempdb`.

### **Ejemplo de C칩digo**
```sql
-- Tabla Temporal F칤sica
CREATE TABLE #tempTable (
    ID INT PRIMARY KEY,
    Nombre VARCHAR(50)
);

INSERT INTO #tempTable VALUES (1, 'Rodrigo'), (2, 'Carlos');

SELECT * FROM #tempTable;

DROP TABLE #tempTable; -- Se elimina cuando ya no se necesita

-- Tabla Temporal en Memoria
DECLARE @tableVariable TABLE (
    ID INT PRIMARY KEY,
    Nombre VARCHAR(50)
);

INSERT INTO @tableVariable VALUES (1, 'Ana'), (2, 'Luis');

SELECT * FROM @tableVariable;
```

4. El operador `RANK()` en SQL Server se usa para asignar un **rango** a cada fila dentro de una partici칩n, basado en una columna espec칤fica ordenada. La diferencia clave con `DENSE_RANK()` es que `RANK()` deja espacios en la numeraci칩n cuando hay empates.

### **Ejemplo 1: Ranking por cantidad de goles**
Queremos ordenar los partidos seg칰n el total de goles anotados y asignarles un **rango**.

```sql
SELECT 
    matchid,
    caption,
    homeid,
    visitorid,
    homegoals,
    visitorgoals,
    (homegoals + visitorgoals) AS total_goals,
    RANK() OVER (ORDER BY (homegoals + visitorgoals) DESC) AS rank_position
FROM dbo.fut_matches;
```
游댳 Esto asigna un **rango** a cada partido, donde el de mayor cantidad de goles recibe el `rank = 1`.  
游댳 Si hay dos partidos con los mismos goles, comparten el mismo `rank`, pero el siguiente n칰mero se **salta** (Ej: 1, 1, 3).

---

### **Ejemplo 2: Ranking por fecha del partido**
Si queremos clasificar los partidos **m치s recientes primero**, podemos hacerlo as칤:

```sql
SELECT 
    matchid,
    caption,
    matchtime,
    homegoals,
    visitorgoals,
    RANK() OVER (ORDER BY matchtime DESC) AS recent_rank
FROM dbo.fut_matches;
```
游댳 Aqu칤, el `RANK()` asigna el `1` al partido m치s reciente y sigue en orden descendente.

Podemos usar PARTITION BY para calcular el ranking de partidos por cada equipo, asegurando que los rankings sean independientes para cada homeid o visitorid.

```sql
SELECT 
    matchid,
    caption,
    homeid,
    visitorid,
    homegoals,
    visitorgoals,
    (homegoals + visitorgoals) AS total_goals,
    RANK() OVER (PARTITION BY homeid ORDER BY (homegoals + visitorgoals) DESC) AS home_team_rank
FROM dbo.fut_matches;
```

5. En SQL Server, existen tres tipos principales de 칤ndices que pueden mejorar la eficiencia de las consultas:

### **1. 칈ndice Clustered (`CLUSTERED`)**
游늷 **Estructura de datos:** 츼rbol B+  
游늷 **Caso de uso:** Se recomienda cuando se necesitan b칰squedas r치pidas basadas en la clave primaria o cuando los datos se recuperan en un orden espec칤fico.  

Un **칤ndice clustered** ordena f칤sicamente los datos en la tabla seg칰n los valores del 칤ndice. Como cada tabla solo puede tener **un 칤ndice clustered**, generalmente se define sobre la clave primaria.

**Ejemplo de declaraci칩n:**
```sql
-- 칈ndice clustered en la clave primaria
CREATE CLUSTERED INDEX IX_FutBets_MatchID 
ON dbo.fut_bets (matchid);
```
游댳 Este 칤ndice ordena f칤sicamente la tabla seg칰n `matchid`, mejorando consultas que filtran por este campo.

---

### **2. 칈ndice No Clustered (`NONCLUSTERED`)**
游늷 **Estructura de datos:** 츼rbol B+  
游늷 **Caso de uso:** Ideal para mejorar el rendimiento de consultas que buscan valores espec칤ficos sin alterar el orden f칤sico de la tabla.  

Un **칤ndice no clustered** crea una estructura separada donde almacena la columna indexada junto con un puntero a la fila correspondiente en la tabla.

**Ejemplo de declaraci칩n:**
```sql
-- 칈ndice no clustered en customerid
CREATE NONCLUSTERED INDEX IX_FutBets_CustomerID 
ON dbo.fut_bets (customerid);
```
游댳 Este 칤ndice acelera consultas que buscan apuestas por cliente (`customerid`), sin modificar la disposici칩n f칤sica de los datos.

---

### **3. 칈ndice Filtrado (`FILTERED`)**
游늷 **Estructura de datos:** 츼rbol B+, con partici칩n l칩gica  
游늷 **Caso de uso:** Se recomienda cuando las consultas acceden a un subconjunto de registros con alta frecuencia.  

Un **칤ndice filtrado** es 칰til cuando se requiere optimizar b칰squedas en una fracci칩n espec칤fica de datos dentro de una columna.

**Ejemplo de declaraci칩n:**
```sql
-- 칈ndice filtrado en apuestas ganadas
CREATE NONCLUSTERED INDEX IX_FutBets_WinningBets 
ON dbo.fut_bets (amountWon)
WHERE amountWon IS NOT NULL;
```
游댳 Este 칤ndice acelera consultas que buscan solo apuestas ganadas (`amountWon IS NOT NULL`), ignorando registros no relevantes.  

6. Cap칤tulo 19 del libro de navathe, algoritmos para SELECT y JOIN: S1 a S9, y J1 J4. 

