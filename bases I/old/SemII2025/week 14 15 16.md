# Optimización de consultas

Optimizar consultas SQL es una práctica esencial para garantizar el rendimiento y la escalabilidad de sistemas que dependen de bases de datos relacionales. Hoy en día, gracias al avance de la inteligencia artificial, es sorprendentemente sencillo generar consultas funcionales, incluso complejas, con solo describir lo que se necesita. Muchas herramientas basadas en AI permiten crear stored procedures, vistas o scripts completos a partir de plantillas, ejemplos previos o descripciones en lenguaje natural. Esto ha democratizado el acceso a la escritura de SQL, permitiendo que perfiles no especializados puedan construir soluciones funcionales rápidamente.

Sin embargo, que una consulta funcione no significa que esté optimizada. Hay al menos tres situaciones comunes donde una AI puede generar SQL que, aunque correcto, tiene un rendimiento subóptimo o no aprovecha las capacidades modernas del motor de base de datos:

1. **Uso excesivo de subconsultas en vez de JOINs eficientes**  
   Las AI pueden generar consultas que usan subconsultas anidadas para filtrar datos, lo cual puede ser más costoso que un JOIN bien estructurado. Por ejemplo:

   ```sql
   SELECT name
   FROM customers
   WHERE id IN (
     SELECT customer_id
     FROM orders
     WHERE total > 100
   );
   ```

   Aunque funcional, esta consulta puede ser menos eficiente que una versión con JOIN:

   ```sql
   SELECT DISTINCT c.name
   FROM customers c
   JOIN orders o ON c.id = o.customer_id
   WHERE o.total > 100;
   ```

2. **Ignorar índices disponibles o no usar filtros selectivos**  
   Una AI puede generar consultas que no aprovechan los índices existentes, especialmente si no conoce la estructura de la base. Aplicar funciones directamente sobre columnas indexadas invalida el uso del índice, lo que puede causar escaneos completos de tabla. Por ejemplo:

   ```sql
   SELECT * FROM transactions
   WHERE YEAR(transaction_date) = 2023;
   ```

   Esta consulta fuerza un escaneo completo si `transaction_date` está indexado, porque la función `YEAR()` impide el uso del índice. Una versión optimizada sería:

   ```sql
   SELECT * FROM transactions
   WHERE transaction_date BETWEEN '2023-01-01' AND '2023-12-31';
   ```

3. **No aprovechar instrucciones modernas como CTEs o funciones de ventana**  
   Algunas AI aún generan SQL con estructuras tradicionales, sin usar Common Table Expressions (CTEs) o funciones de ventana que pueden mejorar legibilidad y rendimiento. Por ejemplo:

   ```sql
   SELECT department, MAX(salary)
   FROM employees
   GROUP BY department;
   ```

   Si se quiere incluir más columnas del empleado con mayor salario, una AI podría generar una subconsulta compleja. Pero con funciones de ventana, se puede hacer más limpio:

   ```sql
   SELECT department, name, salary
   FROM (
     SELECT department, name, salary,
            RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rnk
     FROM employees
   ) e
   WHERE rnk = 1;
   ```

4. **Consulta con rendimiento subóptimo por orden de tablas en el JOIN**

Cuando se hace un JOIN entre una tabla grande y una pequeña, algunos motores de base de datos pueden ejecutar más rápido si se empieza por la tabla pequeña, especialmente si hay índices bien definidos.

```sql
-- Consulta con bajo rendimiento
SELECT o.id, o.total, c.name
FROM orders o
JOIN countries c ON o.country_code = c.code;
```

```sql
-- Consulta optimizada
SELECT o.id, o.total, c.name
FROM countries c
JOIN orders o ON o.country_code = c.code;
```

5. **Consulta con múltiples OR en vez de IN**

Usar OR repetido puede generar planes de ejecución más complejos que una cláusula IN, especialmente si hay índices involucrados.

```sql
-- Consulta con bajo rendimiento
SELECT * 
FROM users 
WHERE role = 'admin' 
   OR role = 'editor' 
   OR role = 'moderator';
```

```sql
-- Consulta optimizada
SELECT * 
FROM users 
WHERE role IN ('admin', 'editor', 'moderator');
```

En resumen, aunque la AI facilita la generación de SQL funcional, es fundamental revisar y optimizar las consultas para que aprovechen las capacidades del motor de base de datos, los índices disponibles y las instrucciones modernas. La colaboración entre humanos y AI puede ser poderosa si se combina la velocidad de generación con el criterio técnico. ¿Quieres que prepare una guía de revisión para QA o un ejercicio técnico sobre esto?



# Diseño de base de dato ante LLMs, RAG y diseño por agentes

Uno de los aspectos que ha empezado a tomar fuerza en los últimos años, son las modificaciones de la forma de diseñar con la aparición de las AI, LLMs, diseño de agentes y otros algoritmos de aprendizaje supervisado y no supervisado. 


## Consideraciones en el diseño del modelo de datos 

### Incorporación de Semántica y Ontologías en el Modelo Relacional

*relaciones:* Se agregan tablas de metadatos semánticos, relaciones tipo "es un", "tiene", "parte de", etc.

*columnas semánticas:* Se usan columnas adicionales o tablas auxiliares para anotar entidades con etiquetas semánticas, categorías o clases.

```sql
CREATE TABLE Producto (
  id INT PRIMARY KEY,
  nombre VARCHAR(100),

  -- categoria_semantica: 'Dispositivo Electrónico' , 'Motor', o 'motor motorizado combustion mecánico'   
  categoria_semantica VARCHAR(100), 
  precio DECIMAL(16,2),
  product_categoryid INT NOT NULL,
  descripcion TEXT NOT NULL
)
```

### Audit Logs y procedencia de los datos de forma estructurada

Se integran tablas para rastrear el origen de los datos , cambios y su contexto, incluyendo quién, cuándo, y por qué se hizo una actualización. Esto le permite a los LLMs razonar sobre la validez y origen de los datos, quiénes los están usando, cómo los están usando o generando, cuándo suceden las cosas, la periodicidad y el tipo de comportamiento que se espera de las acciones. 

Tal cual como lo hacemos en diseño de tablas de logs

![Image](./media/logtabledesign.png)

### Inyección de Datos Naturales y Representaciones Textuales en Tablas

Se agregan columnas textuales diseñadas para ayudar a la comprensión de LLMs como descripciones, ejemplos, resúmenes, prompts embebidos. Incluso se pueden almacenar embeddings en bases relacionales extendidas (como PostgreSQL con extensiones vectoriales).  Aquí se recomienda investigar sobre bases de datos vectoriales tales como: faiss, pinecone, weaviate. 

### Metadatos a incorporar: 

- Descripciones naturales de entidades y relaciones. 

- Trazabilidad de datos: cuándo, cómo y por quién fueron creados o modificados. 

- Ontologías ligeras o taxonomías internas. 

- Embeddings o referencias cruzadas hacia datos no estructurados (como documentos, imágenes, etc.). 

- Mapeo a APIs externas o fuentes contextuales que los agentes puedan consultar. 


_*Qué se pretende lograr con esta extensión del diseño?*_ 

https://www.akira.ai/blog/ai-agents-in-relational-rag 


## Nuevos patrones de diseño arquitectónicos y de objetos orientados a agentes 

Estudiar el siguiente artículo de referencia sin embargo es importante profundizar en cada patrón según sea necesario : 

https://lekha-bhan88.medium.com/introduction-to-agentic-ai-and-its-design-patterns-af8b7b3ef738 

_*Qué es lo que estamos buscando lograr con esta óptica del diseño?*_

https://vectorize.io/designing-agentic-ai-systems-part-4-data-retrieval-and-agentic-rag/ 



